[{"title":"[正则表达式与web前端] 一剂偏方，重构你的文章","tag":["前端","正则表达式"],"time":"2016-10-21 04:48:00","url":"/post/2016-10-21T04:48:00_regexp-skill","thumb":"/contents/2016-10-21T04:48:00_regexp-skill/thumb.jpg","content":"正则表达式是处理文本、数据的一剂良药，吃久了吃惯了才不觉得苦，PO主久病多年苦无良医，所以捣鼓了一些针对web前端方面的偏方。\n\n**【 功能主治 】**\n\n适用于以下人群及症状：\n* 内容妹纸：从网上拷下来的文章样式太乱，拿人手短。。。\n* 前端妹纸：某些内容的排版太繁琐，不想浪费青春。。。\n* 爬虫汉子：扒到的文章内容有点污，不想手洗。。。\n\n**【 禁忌人群 】**\n\n以下人群可能存在不良反应，请慎用此方：\n* 岁月静好，不怕麻烦和浪费青春的；\n* 有更牛X解决方案的；\n* 觉得我本人无聊的。。。\n\n下面以JS代码举例，主要介绍本人百无聊赖时总结出的一些短（lai）小（da）精（wo）悍（ya）的代码，用来重新定义和优化网页上的文章内容。\n\n### 1. 行内样式，洗洗更健康\n\n对于 css 样式来说，诸如 ```style=\"...\"``` 和 ```height=\"...\"``` 这样的行内样式，由于其优先级较高，容易一上场就干掉很多我们殚精竭虑码完的 css 样式。因此，如果你手里头有类似于下面这段 html 的代码，请务必先洗一洗：\n\n```html\n<div id=\"news-content\" class=\"news-content\"><!--content_start--><!--content_start--><p>　　2016年10月20日，在第七届中国高成长企业CEO峰会上，第十一届“中国最具投资价值企业50强”评选榜单（以下简称V50榜单）正式发布。该榜自2006年以来，至今已举办十一年之久，是投资界首个专注高成长企业的年度评选活动，被誉为“行业投资风向标”。</p><p>　　本届榜单在2015年风格的基础上进行了微调，根据企业发展的不同阶段与规模，将“中国最具投资价值企业50强”榜单评选，细分为“风云榜”（融资阶段A轮及其以后的未上市企业）和“新芽榜”（融资阶段A轮以前的未上市企业，创立时间两年以内）。</p><p>　　本届V50评选，自2016年3月初全面启动以来，广泛征集报名企业，经首轮筛选进入初评的企业达1000+，再通过严格的初评和复评，汇聚了近百位投资界“意见领袖”及<a href=\"http://newseed.pedaily.cn/company/2529\" target=\"_blank\">精英</a>们的专业意见，最终缔造了本届中国最具投资价值企业风云榜50强和新芽榜50强！</p><div><table border=\"1\"><tbody><tr><td colspan=\"3\"><p style=\"text-align:center;\"><b>2016</b><b>年第十一届中国最具投资价值企业50强榜单·新芽榜</b></p><p style=\"text-align:center;\">（此榜单排名不分先后，按企业全称首字母排序）</p></td></tr><tr><td><p><b>序号</b></p></td><td><p><b>企业简称</b></p></td><td><p><b>公司名称</b></p></td></tr><tr><td><p><b>1</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43432\" target=\"_blank\">POMCube</a></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43432\" target=\"_blank\">POMCube</a><a href=\"http://newseed.pedaily.cn/company/28649\" target=\"_blank\">Inc</a>.</p></td></tr><tr><td><p><b>2</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43348\" target=\"_blank\">京华未来</a></p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/43348\" target=\"_blank\">京华未来</a>机器人科技有限公司</p></td></tr><tr><td><p><b>3</b></p></td><td><p>玲珑</p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/38816\" target=\"_blank\">科玲文化科技</a>有限公司</p></td></tr><tr><td><p><b>4</b></p></td><td><p>联想<a href=\"http://zdb.pedaily.cn/people/智慧/\" target=\"_blank\">智慧</a>医疗</p></td><td><p>北京联想<a href=\"http://zdb.pedaily.cn/people/智慧/\" target=\"_blank\">智慧</a>医疗信息技术公司</p></td></tr><tr><td><p><b>5</b></p></td><td><p>灵犀微光</p></td><td><p>北京灵犀微光科技有限公司</p></td></tr><tr><td><p><b>6</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/42856\" target=\"_blank\">美信金融</a></p></td><td><p>北京美信众诚科技有限公司</p></td></tr><tr><td><p><b>7</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43249\" target=\"_blank\">魔视互动</a></p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/43249\" target=\"_blank\">魔视互动</a>科技有限公司</p></td></tr><tr><td><p><b>8</b></p></td><td><p>魔数科技</p></td><td><p>北京魔数科技有限公司</p></td></tr><tr><td><p><b>9</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/41882\" target=\"_blank\">潜力股</a></p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/41882\" target=\"_blank\">潜力股</a>科技有限公司</p></td></tr><tr><td><p><b>10</b></p></td><td><p>斑马社</p></td><td><p>北京青云<a href=\"http://newseed.pedaily.cn/company/28217\" target=\"_blank\">互帮</a>网络科技有限公司</p></td></tr><tr><td><p><b>11</b></p></td><td><p>深鉴科技</p></td><td><p>北京深鉴科技有限公司</p></td></tr><tr><td><p><b>12</b></p></td><td><p>住范儿</p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/42325\" target=\"_blank\">水木优品</a>科技有限公司</p></td></tr><tr><td><p><b>13</b></p></td><td><p>万娱引力</p></td><td><p>北京万娱引力文化传媒有限公司</p></td></tr><tr><td><p><b>14</b></p></td><td><p>细刻科技</p></td><td><p>北京细刻网络科技有限公司</p></td></tr><tr><td><p><b>15</b></p></td><td><p>医洋科技</p></td><td><p>北京医洋科技有限公司</p></td></tr><tr><td><p><b>16</b></p></td><td><p>艺妙神州</p></td><td><p>北京艺妙<a href=\"http://newseed.pedaily.cn/company/21983\" target=\"_blank\">神州医疗</a>科技有限公司</p></td></tr><tr><td><p><b>17</b></p></td><td><p>有序科技</p></td><td><p>北京有序科技有限公司</p></td></tr><tr><td><p><b>18</b></p></td><td><p>91金服</p></td><td><p>北京众智人人信息科技有限责任公司</p></td></tr><tr><td><p><b>19</b></p></td><td><p>水滴互助</p></td><td><p>北京<a href=\"http://newseed.pedaily.cn/company/42462\" target=\"_blank\">纵情向前</a>科技有限公司</p></td></tr><tr><td><p><b>20</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43061\" target=\"_blank\">天仪研究院</a></p></td><td><p>长沙天仪空间科技研究院有限公司</p></td></tr><tr><td><p><b>21</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/42633\" target=\"_blank\">11Space</a></p></td><td><p>畅联管理咨询（北京）有限公司</p></td></tr><tr><td><p><b>22</b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/39083\" target=\"_blank\">比呀比</a></p></td><td><p>广州<a href=\"http://newseed.pedaily.cn/company/39083\" target=\"_blank\">比呀比</a>信息科技有限公司</p></td></tr><tr><td><p><b>23</b></p></td><td><p><a href=\"http://zdb.pedaily.cn/people/金华/\" target=\"_blank\">金华</a>佗</p></td><td><p>广州杜仲哥互联网科技有限公司</p></td></tr><tr><td><p><b>24</b></p></td><td><p>康立明生物</p></td><td><p>广州市康立明生物科技有限责任公司</p></td></tr><tr><td><p><b>25</b></p></td><td><p>国民认证</p></td><td><p>国民认证科技（北京）有限公司</p></td></tr><tr><td><p><b>26</b><b></b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43634\" target=\"_blank\">维权骑士</a></p></td><td><p>杭州刀豆网络科技有限公司</p></td></tr><tr><td><p><b>27</b><b></b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/42379\" target=\"_blank\">文签网络</a></p></td><td><p>杭州<a href=\"http://newseed.pedaily.cn/company/42379\" target=\"_blank\">文签网络</a>技术有限公司</p></td></tr><tr><td><p><b>28</b><b></b></p></td><td><p>空中云汇</p></td><td><p>空中云汇（深圳）网络科技有限公司</p></td></tr><tr><td><p><b>29</b><b></b></p></td><td><p>爱诺医药</p></td><td><p>宁波爱诺医药科技有限公司</p></td></tr><tr><td><p><b>30</b><b></b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/43199\" target=\"_blank\">埃德斯</a></p></td><td><p>上海<a href=\"http://newseed.pedaily.cn/company/43199\" target=\"_blank\">埃德斯</a>生物科技有限公司</p></td></tr><tr><td><p><b>31</b><b></b></p></td><td><p>幼师口袋</p></td><td><p>上海必加教育科技有限公司</p></td></tr><tr><td><p><b>32</b><b></b></p></td><td><p>果藤金融</p></td><td><p>上海果藤互联网金融信息服务有限公司</p></td></tr><tr><td><p><b>33</b><b></b></p></td><td><p>禾赛科技</p></td><td><p>上海禾赛<a href=\"http://newseed.pedaily.cn/company/23214\" target=\"_blank\">光电科技</a>有限公司</p></td></tr><tr><td><p><b>34</b><b></b></p></td><td><p><a href=\"http://newseed.pedaily.cn/company/42401\" target=\"_blank\">金枣金融</a></p></td><td><p>上海<a href=\"http://newseed.pedaily.cn/company/42401\" target=\"_blank\">金枣金融</a>信息服务有限公司</p></td></tr><tr><td><p><b>35</b><b></b></p></td><td><p>哮喘管家</p></td><td><p>上海朔茂网络科技有限公司</p></td></tr><tr><td><p><b>36</b><b></b></p></td><td><p>烯牛数据</p></td><td><p>上海烯牛信息技术有限公司</p></td></tr><tr><td><p><b>37</b><b></b></p></td><td><p>朋友印象</p></td><td><p>上海<a href=\"http://newseed.pedaily.cn/company/40089\" target=\"_blank\">阅人信息技术</a>有限公司</p></td></tr><tr><td><p><b>38</b><b></b></p></td><td><p>快金数据</p></td><td><p>深圳快金数据技术服务有限公司</p></td></tr><tr><td><p><b>39</b><b></b></p></td><td><p>莱斯购</p></td><td><p>深圳市莱斯购电子商务有限公司</p></td></tr><tr><td><p><b>40</b><b></b></p></td><td><p>寻材问料</p></td><td><p>深圳市寻材问料网络科技有限公司</p></td></tr><tr><td><p><b>41</b><b></b></p></td><td><p>万<a href=\"http://newseed.pedaily.cn/company/29464\" target=\"_blank\">瑞达</a>生物</p></td><td><p>深圳万<a href=\"http://newseed.pedaily.cn/company/29464\" target=\"_blank\">瑞达</a>生物科技有限公司</p></td></tr><tr><td><p><b>42</b><b></b></p></td><td><p>英美达</p></td><td><p>深圳英美达医疗技术有限公司</p></td></tr><tr><td><p><b>43</b><b></b></p></td><td><p>0glass</p></td><td><p>深圳增强现实技术有限公司</p></td></tr><tr><td><p><b>44</b><b></b></p></td><td><p>欧瑞吉医药</p></td><td><p>四川欧瑞吉生物医药股份有限公司</p></td></tr><tr><td><p><b>45</b><b></b></p></td><td><p>玩咖</p></td><td><p>玩咖欢聚文化传媒（北京）有限公司</p></td></tr><tr><td><p><b>46</b><b></b></p></td><td><p>一起火</p></td><td><p>衣旗（杭州）科技有限公司</p></td></tr><tr><td><p><b>47</b><b></b></p></td><td><p>标准普惠</p></td><td><p>颐月信息技术（北京）有限公司</p></td></tr><tr><td><p><b>48</b><b></b></p></td><td><p>水滴科技</p></td><td><p>银河水滴科技（北京）有限公司</p></td></tr><tr><td><p><b>49</b><b></b></p></td><td><p>娱猫</p></td><td><p>娱猫（北京）科技有限公司</p></td></tr><tr><td><p><b>50</b><b></b></p></td><td><p>北斗云点</p></td><td><p>珠海北斗云点信息技术有限公司</p></td></tr></tbody></table></div><p style=\"text-align:center;\">![新芽榜·2016年中国最具投资价值企业50强榜单](http://upload-images.jianshu.io/upload_images/590155-14755fa8a7bf8d94?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</p><p>　　<b>关于<a href=\"http://newseed.pedaily.cn/vc/38531\" target=\"_blank\">清科集团</a></b></p><p>　　<a href=\"http://newseed.pedaily.cn/vc/38531\" target=\"_blank\">清科集团</a>：成立于1999年，是中国领先的创业与投资综合服务平台及投资机构。旗下包括：清科研究中心、清科传媒、清科资本、清科财富、<a href=\"http://newseed.pedaily.cn/vc/110\" target=\"_blank\">清科创投</a>、清科母基金。主要业务涉及：研究咨询、数据产品、会议论坛、信息资讯、投资银行服务、直接投资、母基金管理及财富管理。</p><!--content_end--><!--content_pagestart--> <!--content_pageend--></div>\n```\n\n首先来清理一下这一坨里面的形如 ```<!--XXX-->``` 这样的注释语句和一些换行符（```\\n```, ```\\t```, ```\\r```）：\n\n```js\n// 这里用htmlStr表示刚才你看到的上面那一坨\nlet htmlStr = '...';\n// 匹配无用代码的正则\nlet pattForUselessCode = /(\\n|\\t|\\r|\\<\\!\\-\\-[^\\>]*\\-\\-\\>)/gi;\n// 将匹配项替换为空字符(即将无用代码从html字符串中剔除)\nhtmlStr = htmlStr.replace(pattForUselessCode, '');\n```\n\n接下来，清理 ```style=\"...\"``` 形式的行内样式：\n\n```js\nlet pattForStyleInline = /\\s(style)\\=\\\"[^\\\"]*\\\"/gi;    // 匹配行内样式的正则\nhtmlStr = htmlStr.replace(pattForStyleInline, '');\n```\n\n清理 ```height=\"...\"``` 形式的行内样式（主要目的在于清理 ```<img>``` 元素的行内宽度和高度，方便你在 css 中自己定义新的样式）：\n\n```js\nlet pattForSizeInline = /(\\s(height)\\=\\\"[^\\\"]*\\\"|\\s(width)\\=\\\"[^\\\"]*\\\")/gi;    // 匹配行内高、宽的正则\nhtmlStr = htmlStr.replace(pattForSizeInline, '');\n```\n\n注意：适当留下些有用的东西，比如：将 ```<p>``` 标签的 ```style=\"text-align:center\"``` 的样式通过 ```class``` 保留下来，我们可以知道哪些文字需要居中；将标签原有的 ```id```, ```class``` 等内容保留下来，也方便我们后期丰富 css 细节时，可以直接使用：\n\n```js\n// 匹配文字水平居中的p标签的正则\nlet pattForTextHorizontally = /\\<p[^(style|\\>)]+style\\=\\\"[^(\\\"|text)]*text\\-align\\:center\\;[^\\\"]*\\\"[^\\>]*\\>/gi;\n// 将<p style=\"...text-align:center...\">替换为<p class=\"text-center\">，而.text-center元素的样式你可以在css里面自己定义\nhtmlStr = htmlStr.replace(pattForTextHorizontally, '<p class=\"text-center\">');\n```\n\n做完上面这些工作，你就可以安安心心去写 css 了。。。这里我就不赘述了。。。\n\n灵活运用标签和选择器，你会发现，大多数网站的文章内容，虽然标签、结构不尽相同，但你仍能统一他们的表现风格。毕竟，经过清洗后留下来的东西，都是比较简单清晰的结构。\n\n最开始的那一坨，经过清理后，大概长这样：\n\n```html\n<div id=\"news-content\" class=\"news-content\"><p>　　2016年10月20日，在第七届中国高成长企业CEO峰会上，第十一届“中国最具投资价值企业50强”评选榜单（以下简称V50榜单）正式发布。该榜自2006年以来，至今已举办十一年之久，是投资界首个专注高成长企业的年度评选活动，被誉为“行业投资风向标”。</p><p>　　本届榜单在2015年风格的基础上进行了微调，根据企业发展的不同阶段与规模，将“中国最具投资价值企业50强”榜单评选，细分为“风云榜”（融资阶段A轮及其以后的未上市企业）和“新芽榜”（融资阶段A轮以前的未上市企业，创立时间两年以内）。</p><p>　　本届V50评选，自2016年3月初全面启动以来，广泛征集报名企业，经首轮筛选进入初评的企业达1000+，再通过严格的初评和复评，汇聚了近百位投资界“意见领袖”及精英们的专业意见，最终缔造了本届中国最具投资价值企业风云榜50强和新芽榜50强！</p><div><table cellpadding=\"0\" cellspacing=\"0\"><tbody><tr class=\"light-row\"><td colspan=\"3\"><p class=\"text-center\"><b>2016</b><b>年第十一届中国最具投资价值企业50强榜单·新芽榜</b></p><p class=\"text-center\">（此榜单排名不分先后，按企业全称首字母排序）</p></td></tr><tr><td class=\"dark-line\"><p><b>序号</b></p></td><td><p><b>企业简称</b></p></td><td class=\"dark-line\"><p><b>公司名称</b></p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>1</b></p></td><td><p>POMCube</p></td><td class=\"dark-line\"><p>POMCubeInc.</p></td></tr><tr><td class=\"dark-line\"><p><b>2</b></p></td><td><p>京华未来</p></td><td class=\"dark-line\"><p>北京京华未来机器人科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>3</b></p></td><td><p>玲珑</p></td><td class=\"dark-line\"><p>北京科玲文化科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>4</b></p></td><td><p>联想智慧医疗</p></td><td class=\"dark-line\"><p>北京联想智慧医疗信息技术公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>5</b></p></td><td><p>灵犀微光</p></td><td class=\"dark-line\"><p>北京灵犀微光科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>6</b></p></td><td><p>美信金融</p></td><td class=\"dark-line\"><p>北京美信众诚科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>7</b></p></td><td><p>魔视互动</p></td><td class=\"dark-line\"><p>北京魔视互动科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>8</b></p></td><td><p>魔数科技</p></td><td class=\"dark-line\"><p>北京魔数科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>9</b></p></td><td><p>潜力股</p></td><td class=\"dark-line\"><p>北京潜力股科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>10</b></p></td><td><p>斑马社</p></td><td class=\"dark-line\"><p>北京青云互帮网络科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>11</b></p></td><td><p>深鉴科技</p></td><td class=\"dark-line\"><p>北京深鉴科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>12</b></p></td><td><p>住范儿</p></td><td class=\"dark-line\"><p>北京水木优品科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>13</b></p></td><td><p>万娱引力</p></td><td class=\"dark-line\"><p>北京万娱引力文化传媒有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>14</b></p></td><td><p>细刻科技</p></td><td class=\"dark-line\"><p>北京细刻网络科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>15</b></p></td><td><p>医洋科技</p></td><td class=\"dark-line\"><p>北京医洋科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>16</b></p></td><td><p>艺妙神州</p></td><td class=\"dark-line\"><p>北京艺妙神州医疗科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>17</b></p></td><td><p>有序科技</p></td><td class=\"dark-line\"><p>北京有序科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>18</b></p></td><td><p>91金服</p></td><td class=\"dark-line\"><p>北京众智人人信息科技有限责任公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>19</b></p></td><td><p>水滴互助</p></td><td class=\"dark-line\"><p>北京纵情向前科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>20</b></p></td><td><p>天仪研究院</p></td><td class=\"dark-line\"><p>长沙天仪空间科技研究院有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>21</b></p></td><td><p>11Space</p></td><td class=\"dark-line\"><p>畅联管理咨询（北京）有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>22</b></p></td><td><p>比呀比</p></td><td class=\"dark-line\"><p>广州比呀比信息科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>23</b></p></td><td><p>金华佗</p></td><td class=\"dark-line\"><p>广州杜仲哥互联网科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>24</b></p></td><td><p>康立明生物</p></td><td class=\"dark-line\"><p>广州市康立明生物科技有限责任公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>25</b></p></td><td><p>国民认证</p></td><td class=\"dark-line\"><p>国民认证科技（北京）有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>26</b><b></b></p></td><td><p>维权骑士</p></td><td class=\"dark-line\"><p>杭州刀豆网络科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>27</b><b></b></p></td><td><p>文签网络</p></td><td class=\"dark-line\"><p>杭州文签网络技术有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>28</b><b></b></p></td><td><p>空中云汇</p></td><td class=\"dark-line\"><p>空中云汇（深圳）网络科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>29</b><b></b></p></td><td><p>爱诺医药</p></td><td class=\"dark-line\"><p>宁波爱诺医药科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>30</b><b></b></p></td><td><p>埃德斯</p></td><td class=\"dark-line\"><p>上海埃德斯生物科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>31</b><b></b></p></td><td><p>幼师口袋</p></td><td class=\"dark-line\"><p>上海必加教育科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>32</b><b></b></p></td><td><p>果藤金融</p></td><td class=\"dark-line\"><p>上海果藤互联网金融信息服务有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>33</b><b></b></p></td><td><p>禾赛科技</p></td><td class=\"dark-line\"><p>上海禾赛光电科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>34</b><b></b></p></td><td><p>金枣金融</p></td><td class=\"dark-line\"><p>上海金枣金融信息服务有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>35</b><b></b></p></td><td><p>哮喘管家</p></td><td class=\"dark-line\"><p>上海朔茂网络科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>36</b><b></b></p></td><td><p>烯牛数据</p></td><td class=\"dark-line\"><p>上海烯牛信息技术有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>37</b><b></b></p></td><td><p>朋友印象</p></td><td class=\"dark-line\"><p>上海阅人信息技术有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>38</b><b></b></p></td><td><p>快金数据</p></td><td class=\"dark-line\"><p>深圳快金数据技术服务有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>39</b><b></b></p></td><td><p>莱斯购</p></td><td class=\"dark-line\"><p>深圳市莱斯购电子商务有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>40</b><b></b></p></td><td><p>寻材问料</p></td><td class=\"dark-line\"><p>深圳市寻材问料网络科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>41</b><b></b></p></td><td><p>万瑞达生物</p></td><td class=\"dark-line\"><p>深圳万瑞达生物科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>42</b><b></b></p></td><td><p>英美达</p></td><td class=\"dark-line\"><p>深圳英美达医疗技术有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>43</b><b></b></p></td><td><p>0glass</p></td><td class=\"dark-line\"><p>深圳增强现实技术有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>44</b><b></b></p></td><td><p>欧瑞吉医药</p></td><td class=\"dark-line\"><p>四川欧瑞吉生物医药股份有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>45</b><b></b></p></td><td><p>玩咖</p></td><td class=\"dark-line\"><p>玩咖欢聚文化传媒（北京）有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>46</b><b></b></p></td><td><p>一起火</p></td><td class=\"dark-line\"><p>衣旗（杭州）科技有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>47</b><b></b></p></td><td><p>标准普惠</p></td><td class=\"dark-line\"><p>颐月信息技术（北京）有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>48</b><b></b></p></td><td><p>水滴科技</p></td><td class=\"dark-line\"><p>银河水滴科技（北京）有限公司</p></td></tr><tr class=\"light-row\"><td class=\"dark-line\"><p><b>49</b><b></b></p></td><td><p>娱猫</p></td><td class=\"dark-line\"><p>娱猫（北京）科技有限公司</p></td></tr><tr><td class=\"dark-line\"><p><b>50</b><b></b></p></td><td><p>北斗云点</p></td><td class=\"dark-line\"><p>珠海北斗云点信息技术有限公司</p></td></tr></tbody></table></div><p class=\"text-center\">![新芽榜·2016年中国最具投资价值企业50强榜单](http://upload-images.jianshu.io/upload_images/590155-14755fa8a7bf8d94?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</p><p>　　<b>关于清科集团</b></p><p>　　清科集团：成立于1999年，是中国领先的创业与投资综合服务平台及投资机构。旗下包括：清科研究中心、清科传媒、清科资本、清科财富、清科创投、清科母基金。主要业务涉及：研究咨询、数据产品、会议论坛、信息资讯、投资银行服务、直接投资、母基金管理及财富管理。</p> </div>\n```\n\n### 2. 两句正则实现复杂的 table 明暗交替样式\n\n一般情况下，像 ```<table>``` 这样的东西，从几千年前活到现在，难免有些历史遗留的臭毛病，为保险起见，很多站点在拿到类似元素时，并没有花太多功夫去美化修饰，所以一臭百臭。\n\n下面是新芽（newseed）网站上的一篇文章的截图，可以看出，对于 table 标签的样式，适配的很不好，为曾经怀揣设计理想的我所不能容忍。\n\n![某网站文章页面对 table 标签的适配效果](http://upload-images.jianshu.io/upload_images/590155-cb63ef3fa792be0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n再下面是鄙人使用从该页面扒下来的同样的 html 结构实现的效果：\n\n![改良后的效果](http://upload-images.jianshu.io/upload_images/590155-2afd77f85a8a261c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n披了一件华丽的外套，与光着身子示人的感觉，毕竟有云泥之别。。。\n\n第二张图的样式，实现起来方法很多，主要的难点在于每行的背景色、每列的背景色都是明暗相间的。这个效果做起来，实现的方法有很多种：\n\n如果在客户端渲染页面，可以基于 DOM 操作：\n\n* 通过写一个或两个```for```循环 给 ```<tr>``` ```<td>``` 根据奇、偶数添加相应标记，如： 奇数列 ```<td class=\"light\">``` 偶数列 ```<td class=\"dark\">``` ，然后 css 再进行统一修饰。\n\n* 再考虑 ```:nth-child(even)``` ```:nth-child(odd)``` 这样的 css 伪类选择器写法，同样可以实现；或者用 jQuery 实现：\n\n```js\n$(\"#tab tr:nth-child(even)\").addClass(\"evenRow\");      // 添加偶数行样式\n$(\"#tab tr:nth-child(odd)\").addClass(\"oddRow\");        // 添加奇数行样式\n$(\"#tab td:nth-child(even)\").addClass(\"evenCol\");      // 添加偶数列样式\n$(\"#tab td:nth-child(odd)\").addClass(\"oddCol\");        // 添加奇数列样式\n```\n\n基于本文最初提到的那“坨” html 字符串，无从谈起操作 DOM，因而直接操作字符串：\n\n```js\n// 表格 - 奇数行浅灰\nhtmlStr = htmlStr.replace(/\\<tr\\>(.*?\\<\\/tr\\>\\<tr\\>.*?\\<\\/tr\\>)/gi, '<tr style=\"background:#f8f8f8;\">$1');\n```\n```\n// 表格 - 奇数列浅灰（使用半透明色值，与上面的行的背景色进行叠加）\nhtmlStr = htmlStr.replace(/\\<td\\>(.*?\\<\\/td\\>(\\<td\\>.*?\\<\\/td\\>)?)/gi, '<td style=\"background:rgba(0,0,0,.2);\">$1');\n```\n\n仅此两句，在不额外撰写 css 的情况下，实现了明暗交替的效果。\n"},{"title":"[web前端] JS: reduce 方法实现 webpack 多文件入口","tag":["前端工程化","nodejs"],"time":"2017-02-12 01:42:00","url":"/post/2017-02-12T01:42:00_webpack-skill","thumb":"/contents/2017-02-12T01:42:00_webpack-skill/thumb.jpg","content":"> 这篇日志，在开始接触 webpack 时候就该写了，现在发布也许对一些刚入此坑的童鞋能些许帮助。。。\n即使有点 low，重要的仍是分享\n\n## 1. reduce 方法介绍\n\n### 1.1 简单场景\n\nreduce 函数的设计意图就是方便进行叠加运算：\n\n```js\nvar arr = [0, 1, 2, 3];\n\n// reduce 实现累加\nvar total = arr.reduce(function (pre, cur){\n  return pre + cur;\n}, 0);\n\nconsole.log(total);    // 6\n```\n\n上述代码中，reduce 方法有两个参数，第一个参数是一个 callback，用于进行计算的函数；第二个参数则是累加计算的初始值: 0\nreduce 以 0 作为初始值，从数组第 0 项开始累加，上述代码的计算过程如下：\n\n```js\ntotal = 0;        // => 0\ntotal = 0 + 0;    // => 0\ntotal = 0 + 1;    // => 1\ntotal = 1 + 2;    // => 3\ntotal = 3 + 3;    // => 6\n```\n\n若不设置初始值 0，则 reduce 以数组第 0 项作为初始值，从第 1 项开始累加，其计算过程如下：\n\n```js\ntotal = 0;        // => 0\ntotal = 0 + 1;    // => 1\ntotal = 1 + 2;    // => 3\ntotal = 3 + 3;    // => 6\n```\n\n可以看出，reduce 函数根据初始值 0，不断进行叠加，完成最简单的数组累加。\n\n### 1.2 两种简单的运用场景\n\n第一个 demo，使用 reduce 函数进行二维数组的拼接：\n\n```js\nvar arr = [ [0], [1, 2], [3, 4, 5] ];\n\n// reduce 实现数组拼接\nvar result = arr.reduce(function (pre, cur){\n  return pre.concat(cur);\n}, []);\n\nconsole.log(result);    // [0, 1, 2, 3, 4, 5]\n```\n\n第二个 demo，使用 reduce 函数构造 JSON 数组：\n\n```js\n// 此例演示：将所有员工的姓名进行拆分\nvar staff = ['Bob Dell', 'Johon Jobs', 'Maria July'];\n\n// reduce 构造 JSON 数组\nvar result = staff.reduce(function (arr, full_name){\n  arr.push({\n    first_name: full_name.split(' ')[0],\n    last_name: full_name.split(' ')[1]\n  });\n\n  return arr;\n}, []);\n\nconsole.log(JSON.stringify(result));\n//  [{\"first_name\":\"Bob\",\"last_name\":\"Dell\"},{\"first_name\":\"Johon\",\"last_name\":\"Jobs\"},{\"first_name\":\"Maria\",\"last_name\":\"July\"}]\n```\n\n灵活使用 reduce 函数，能为我们节省不少中间变量和代码。\n\n## 2. 用于实现 webpack 多文件入口配置\n\nwebpack 配置项中```entry```参数用于配置入口文件路径，通常对于只打包一个目录下的文件，只需要遍历该目录，构造一个如下的对象传递给```entry```即可：\n\n```js\n// 注：index.js 为每个页面的入口文件，所有页面均在 ./fe/pages/ 目录下\nvar entry = {\n  index: './fe/pages/home/index.js',\n  list: './fe/pages/list/index.js'\n};\n```\n\n通常，我们使用 reduce 方法来遍历同一目录下的入口：\n\n```js\nvar fs = require('fs');\nvar path = require('path');\n...\n\n// 定义入口路径\nvar entryPath = './fe/pages';\n\n// 遍历路径下多文件入口\nvar entris = fs.readdirSync(entryPath).reduce(function (o, filename) {\n  !/\\./.test(filename) &&\n  (o[filename] = './' + path.join(entryPath, filename, 'index.js'));\n  return o;\n}, {});\n\n// entry = {\n//   index: './fe/pages/home/index.js',\n//   list: './fe/pages/list/index.js'\n// }\n```\n\n对于多页面应用的开发场景，也许会需要构造类似于下面这样的一个对象：\n\n```js\n// 多个入口，页面、公共组件并不一定在同一个目录下\nvar entry = {\n  index: './fe/pages/home/index.js',\n  list: './fe/pages/list/index.js',\n  header: './fe/components/header/index.js',\n  footer: './fe/components/footer/index.js'\n};\n```\n\n可以发现，我们要打包的页面、公共组件不一定在同一个目录下，这时候就需要对原先的方法进行扩展，见代码：\n\n```js\nvar fs = require('fs');\nvar path = require('path');\n...\n\n// 定义入口路径\nvar entryPath = ['./fe/pages', './fe/components'];\n\n// 遍历路径下多文件入口\nvar mkEntriesMap = function (entryPath){\n  if (typeof(entryPath) == 'string') {    // 若 entryPath 为字符串，则直接遍历此目录\n    var path_map = fs.readdirSync(entryPath).map(function (filename){\n      return filename + '::./' + path.join(entryPath, filename, 'index.js');\n    });\n  } else if (typeof(entryPath) == 'object') {    // 若 entryPath 为数组，则进行两级遍历\n    var path_map = entryPath.map(function (entry){\n      return fs.readdirSync(entry).map(function (filename){\n        return filename + '::./' + path.join(entry, filename, 'index.js');\n      });\n    }).reduce(function (preArr, curArr){\n      return preArr.concat(curArr);\n    }, []);\n  } else {\n    throw 'Type of config.entryPath is not valid.';\n    return;\n  }\n\n  return path_map.reduce(function (o, file_map){\n    var file_name = file_map.split('::')[0];\n    var file_path = file_map.split('::')[1];\n\n    if (!/\\./.test(file_name)) {\n      o[file_name] = file_path;\n    }\n\n    return o;\n  }, {});\n};\n\n// 构造对象\nvar entris = mkEntriesMap(entryPath);\n\n// entry = {\n//   index: './fe/pages/home/index.js',\n//   list: './fe/pages/list/index.js',\n//   header: './fe/components/header/index.js',\n//   footer: './fe/components/footer/index.js'\n// }\n```\n\n这样做的好处在于，只需配置一开始的```entryPath```就行了，同时支持单个或多个路径下的文件打包：\n\n```js\n// entryPath 可以为一个字符串\nvar entryPath = './fe/pages';\n\n// entryPath 也可以设为一个数组\nvar entryPath = ['./fe/pages', './fe/components'];\n```\n"},{"title":"[web前端发微] 潇洒地操作 window.history","tag":["前端"],"time":"2017-03-28 02:07:00","url":"/post/2017-03-28T02:07:00_browser-history","thumb":"/contents/2017-03-28T02:07:00_browser-history/thumb.jpg","content":"如果你想在 web 应用实现类似 pjax 的功能特性，往往需要做一些准备，比如对于不支持 history.pushState 方法的部分浏览器，怎样去做优雅降级，以满足页面整体的可用性等等。这篇文章主要来说说 pjax 相关的问题和思路。\n\n## 1. Why pjax?\n\n首先，因为我们必然会用到 ajax 来搞定数据，在 js 中执行的请求和 DOM 操作并不会被 history 记录（这么说虽然不严谨，帮助理解就好）；\n\n其次，单页面应用场景（或者某一个页面有多个交互状态的情况）下，浏览器的前进后退功能无法获取到某一次 ajax 操作或者交互的状态；\n\n第三（你以为我会说最后？so cute!），接前面所述，当页面在某种状态下被分享或者传播时，新的用户进入后，页面本应该维持在上个用户分享或传播时的状态（比如你经常在朋友圈分享的各种活动页面等等）...\n\n基于以上且不限于以上所述的种种需求，pjax 的策略便应运而生。\n\n![PJAX 机制（图片来源：百度搜索）](http://upload-images.jianshu.io/upload_images/590155-0f79eaf9595bd613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 2. Pjax 的机制\n\n参考上面的示意图，用一种简单的方式来描述这个机制的过程：\n\n首先，在执行 ajax 操作时，我们使用 pushState 方法向 浏览器的 history 对象中写入一个特定的状态值（一组参数），保证每一次 ajax 请求都能有一个相应的 history 记录（history.state）；\n\n那么之后，当我们访问 history 的不同状态的时候（比如点击浏览器前进、后退按钮），通过当前状态值我们也能找到与之对应的 ajax 操作。\n\n这里 pushState 方法的一个好处，就是可以在不重载页面的情况下，改写浏览器地址栏 url（同时改变 window.location.href）。\n\n## 3. Pjax 的本质\n\nPjax 给我们提供了一个方案，而不仅仅是 pjax 的本身内容。我们至少可以从两个方面来拓展一下：\n\n> 如果没有 pushState，可以用其他方式来影响浏览器的历史记录吗？\n\n  * 如果你比较了解 React 或者 Angular 的 router 实现，那么这个问题很容易理解。比如 react-router 给予我们两种选择，一种是基于 history.pushState 的路由实现，一种是基于 location.hash 的实现，后者相对前者而言，适用性更强一些，毕竟 锚点 这个东西，在 web1.0 时代我们就很熟悉了。使用 location.hash 能够满足低版本浏览器的需要。\n\n> 如果把 ajax 操作换成其他操作呢？比如一般的 DOM 操作\n\n如此看来，借鉴于 pjax 的机制和原理，我们能干的事情很多。对于需要让浏览器记录的事件操作或者状态，我们按这个套路实现就好了。\n\n## 4. By the way, and how to do?\n\n基于上面的讨论，如果你已经有种想做点什么的冲动。那么，我想我们已经产生了共鸣。\n看到这里，不妨给文章点个赞或者丢几个硬币什么的，十分感激 (Xie-Xie-Ba-Ba)\n\n> 抛开单纯的 pjax 实现（比如 jquery-pjax 等等）\n如果我们可以自己做一个小工具（方法类库之类的）\n利用浏览器的 history 来驱动页面的操作或者行为\n解决更多的问题\n或者实现一个全新的功能\n是不是很 cool ？\n\n## 5. 欲望清单\n\n这个小标题看起来可能的有点中二（或者有点标题党吧）。。。\n\n从需求出发来考虑设计实现（需求驱动），是培养架构能力的好习惯。（~嘤~嘤~嘤）\n\n### 5.1 需求清单:\n\n* 我们想做一个更通用的 pushState 方法，用法如下（考虑逼格，展示 ES6 语法的伪代码）：\n\n```js\n// 以 import 形式引入依赖，easierHistory 是我们最终构造的方法集（一个对象或构造器）或者工具包\nimport easierHis from './easierHistory';\n\n// ...do something...\n\n// 向浏览器历史插入一条记录 （例如：我们做一个翻页的效果时，传入值为一个页码）\neasierHis.putState({page: 3});\n\n/* 注：为与原有 pushState 方法区别，故将新方法命名为 putState */\n```\n\n* 我们想通过一个方法（或者接口）访问到当前的历史状态（更通用的 history.state 方法）：\n\n```js\n// 获取当前历史状态 state\nlet { state } = easierHis.getState();\n\n/* 注：为与原有 state 方法区别，故将新方法命名为 getState */\n```\n\n* 构造一个通用的方法，当进行浏览器前进后退操作时，可以触发一些操作：\n\n```js\n// 获取当前历史状态 state\neasierHis.popState( (state) => { do something... } );\n\n/* 注：这里我们给 popState 方法传入一个回调，回调的内容就是我们想要触发的操作 */\n```\n\n### 5.2 一个完整的需求实例:\n\n综合考虑一个实际的应用场景，比如我们想要用自己构造的这种类 pjax 机制实现一个有记录、可前进回退的翻页效果。大致的实现如下：\n\n```js\nimport easierHis from './easierHistory';\n\n// 默认加载第 1 页数据\nif (!easierHis.getState()) {\n  loadPage(1);      // 用于翻页和加载数据的方法\n  easierHis.putState({page: 1});\n}\n\n// 浏览器前进/后退时，根据 state 数据加载对应页码的数据\neasierHis.popState((state) => {\n  let cur_page = !state ? 1 : parseInt(state.page);\n  loadPage(cur_page);\n});\n\n// 加载或跳转某页的方法\nfunction goto(page){\n  loadPage(page);\n  easierHis.putState({page: page});\n}\n```\n\n## 6. 具体实现\n\n从上一小节的需求出发，我们来看一看这个小工具（包）的具体实现。\n这里直接看代码，行文思路和具体方法的用法，可以参考代码注释：\n\n```js\n/* 基于 ES5 的 easierHistory 实现 */\n'use strict';\n\n// 全局对象\nvar easierHistory = {};\n\n/*\n** @method putState : 实现 类PJAX 机制的辅助函数，用于在 history 菊花上插一刀\n** @param {Object} state_content : 第 1 个参数(必填)，表示当前 state 的对象字面量\n** @param {Boolean} sync_prior : 第 2 个参数(选填)，传 true 则优先使用方案 $1，反之直接使用方案 $2，默认值为 true\n** @return {Object} _state : 返回 state\n**\n** $1 : 基于 history.pushState (绝大部分现代浏览器均支持)\n** $2 : 通过操作 url 的 hash 字符串内容的方式来进行兼容\n*/\neasierHistory.putState = function (state_content, sync_prior) {\n  var _state = arguments[0] || {};\n  var _prior = typeof arguments[1] == 'undefined' ? true : arguments[1];\n\n  // 拼接 search 和 hash 字符串\n  var _search = '?';\n  var _hash = '';\n  for (var key in _state) {\n    _search += key + '=' + _state[key] + '&';\n    _hash += '#' + key + '=' + _state[key];\n  }\n  _search = _search.replace(/\\&$|\\?$/, '');\n\n  // 根据浏览器支持情况，选择一种实现方式\n  if (!history.pushState || !_prior) {\n    location.hash = _hash;                       // $2 基于 location.hash 的实现\n  } else {\n    history.pushState(_state, '', _search);      // $1 基于 pushState 的实现\n  }\n\n  // 返回当前 state\n  return _state;\n}\n\n/*\n** @method getState_byHistory : 用于获取 history 状态\n** @return {Object} curState : 当前 history 状态\n*/\neasierHistory.getState_byHistory = function () {\n  if (history.state) {\n    return history.state;\n  }\n\n  if (location.search) {\n    return location.search.substring(1).split('&').reduce(function (curState, queryStr) {\n      if (queryStr.indexOf('=') !== -1) {\n        curState[queryStr.split('=')[0]] = queryStr.split('=')[1];\n      }\n\n      return curState;\n    }, {});\n  }\n\n  return null;\n};\n\n/*\n** @method getState_byHash : 将 location.hash 的内容解析为 json 对象\n** @return {Object} curState : 转换后的 json 对象\n*/\neasierHistory.getState_byHash = function () {\n  if (!location.hash) {\n    return null;\n  }\n\n  return location.hash.split('#').reduce(function (curState, hashStr) {\n    if (hashStr.indexOf('=') !== -1) {\n      curState[hashStr.split('=')[0]] = hashStr.split('=')[1];\n    }\n\n    return curState;\n  }, {});\n};\n\neasierHistory.getState = function () {\n  return easierHistory.getState_byHistory() || easierHistory.getState_byHash();\n};\n\n/*\n** @method popState : 给 window对象 绑定 popState 事件，若浏览器不支持则向下兼容 hashchange 事件\n** @param {Function} cbFunc : 事件回调\n*/\neasierHistory.popState = function (cbFunc) {\n  if (easierHistory.getState_byHistory()) {\n    window.onpopstate = function () {          // 基于 popstate 方法的实现（html5 特性）\n      cbFunc(easierHistory.getState());\n    };\n  } else {\n    window.onhashchange = function () {        // 基于 hashchange 方法的实现（兼容性更强）\n      cbFunc(easierHistory.getState());\n    };\n  }\n};\n\n\nmodule.exports = easierHistory;\n```\n\n当然，上面的代码可以直接在浏览器运行（直接使用 easierHistory对象），把 module.exports 语句去掉即可。\n"},{"title":"nodejs 终端打印进度条","tag":["nodejs"],"time":"2017-04-21 19:34:00","url":"/post/2017-04-21T19:34:00_nodejs-client-progress-bar","thumb":"/contents/2017-04-21T19:34:00_nodejs-client-progress-bar/thumb.jpg","content":"## 1. 场景导入\n\n当我们对大量文件进行批量处理的时候(例如：上传/下载、保存、编译等)，常常希望知道当前进展如何，或者失败(成功)的任务有多少；当我们的代码或程序已经发布，用户在执行安装的过程中，一个合适的（终端/命令行）进度条可以准确反映安装的步骤和进程，提升程序的可用性，一定程度缓解用户在等待中的烦恼……\n\n## 2. 基本原理\n\n首先，在终端打印出文本是件比较容易的事情。\n那么使用简单的文本和符号，就够自己拼凑出命令行的效果（下面例子）:\n\n```bash\n文件已上传: 43.60% █████████████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░ 150/344\n```\n\n当然，进度条的效果可以根据需要自己设计啦，我这里只是给大家一个参考。\n\n这里，我将打印命令行的方法构造成一个工具模块 `progress-bar.js`，具体实现如下 :-)\n\n```js\n// 这里用到一个很实用的 npm 模块，用以在同一行打印文本\nvar slog = require('single-line-log').stdout;\n\n// 封装的 ProgressBar 工具\nfunction ProgressBar(description, bar_length){\n  // 两个基本参数(属性)\n  this.description = description || 'Progress';       // 命令行开头的文字信息\n  this.length = bar_length || 25;                     // 进度条的长度(单位：字符)，默认设为 25\n\n  // 刷新进度条图案、文字的方法\n  this.render = function (opts){\n    var percent = (opts.completed / opts.total).toFixed(4);    // 计算进度(子任务的 完成数 除以 总数)\n    var cell_num = Math.floor(percent * this.length);             // 计算需要多少个 █ 符号来拼凑图案\n\n    // 拼接黑色条\n    var cell = '';\n    for (var i=0;i<cell_num;i++) {\n      cell += '█';\n    }\n\n    // 拼接灰色条\n    var empty = '';\n    for (var i=0;i<this.length-cell_num;i++) {\n      empty += '░';\n    }\n\n    // 拼接最终文本\n    var cmdText = this.description + ': ' + (100*percent).toFixed(2) + '% ' + cell + empty + ' ' + opts.completed + '/' + opts.total;\n\n    // 在单行输出文本\n    slog(cmdText);\n  };\n}\n\n// 模块导出\nmodule.exports = ProgressBar;\n```\n\n## 3. Run 起来\n\n基于上面的实现，先说一下这个 `progress-bar.js` 的用法：\n\n```js\n// 引入工具模块\nvar ProgressBar = require('./progress_bar');\n\n// 初始化一个进度条长度为 50 的 ProgressBar 实例\nvar pb = new ProgressBar('下载进度', 50);\n\n// 这里只是一个 pb 的使用示例，不包含任何功能\nvar num = 0, total = 200;\nfunction downloading() {\n  if (num <= total) {\n    // 更新进度条\n    pb.render({ completed: num, total: total });\n\n    num++;\n    setTimeout(function (){\n      downloading();\n    }, 500)\n  }\n}\ndownloading();\n```\n\nrun 一下上面的代码，执行效果如下：\n\n![](http://upload-images.jianshu.io/upload_images/590155-0efe80d8c7068908.gif?imageMogr2/auto-orient/strip)\n"},{"title":"3D GIS 应用开发 —— 基于 Mapbox GL 的实践总结","tag":["GIS","webGL","3D可视化","前端"],"time":"2017-09-01 23:29:00","url":"/post/2017-09-01T23:29:00_mapbox-gl-js","thumb":"/contents/2017-09-01T23:29:00_mapbox-gl-js/thumb.jpg","content":"最近在折腾的 web 端的可视化项目，由于相关业务的需要，用到了 Mapbox 这一地图开发的神器。在此先奉上一个基于mapbox-gl实现的demo（来源：[uber的deck.gl项目](https://uber.github.io/deck.gl/#/)）：\n\n![demo](http://upload-images.jianshu.io/upload_images/590155-e16a70b0ec98c157?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n下面我们从这个项目一步步来介绍 Mapbox 的前端 GIS 引擎 [Mapbox GL JS](https://github.com/mapbox/mapbox-gl-js).\n\n## 1. 简单了解\n首先，Mapbox 在地图领域是一家很 Newbee 的公司。已为 Foursquare、Pinterest、Evernote、金融时报、天气频道、优步科技 等公司的网站提供了订制在线地图服务。\n\n自2010年起，该公司快速地拓展了订制地图的市场地位，以回应 Google地图 等地图供应商提供的有限选择。Mapbox 是一些开放源代码地图库及应用程序的创建者或最大的贡献者，其中包含了MBTiles 规范、TileMill 制图 IDE、Leaflet JavaScript 库，以及 CartoCSS 地图格式化语言与语法分析器等。\n\n该公司的数据同时从开放与专有的来源获取，开放的数据源如 开放街图（OSM, Open Street Map） 以及 NASA 等，而专有的数据源则包含了 DigitalGlobe。其技术奠基于 Node.js、CouchDB、Mapnik、GDAL 与 Leafletjs。\n\n[图片上传失败...(image-e27a1b-1515395418070)]\n\nMapbox 针对不同平台均开发了相应的 GIS 引擎以满足开发者或相关用户的需要，如：iOS SDK（用于iOS端开发）、Android SDK（用于Andriod端开发）、Navigation SDK（用于Navigation端开发）、Unity SDK（用于Unity端开发）、GL JS（用于web端开发）。不同平台的SDK，除使用方式不同外，功能特性上也多多少少存在不同。此外，Uber还针对react开发了 [react-map-gl](https://github.com/uber/react-map-gl)。总的来说，Mapbox的开源技术栈是非常全面的。\n\n## 2. 轻松上手\n\n[图片上传失败...(image-426b0b-1515395418070)]\n\nmapbox-gl 的 [文档](https://www.mapbox.com/mapbox-gl-js/api/) 由 API、Style Specification、Example、Plugins 四部分内容组成。\n\n顾名思义，API 是一般框架(类库)提供给用户的全部接口（方法）的说明书；Style Specification 是 Mapbox 地图的样式规范；Example 是一些常用功能或常见业务的代码示例，囊括了使用 Mapbox 所能实现的大部分功能效果；Plugins 则是官方推荐的可与 mapbox-gl 一同使用的一些增效插件和开源项目，如一些第三方的UI控件、显示类插件、框架集成工具、开发辅助工具、实用工具类库等等。\n\n对于初了解 Mapbox 的童鞋，建议先从官网的 Example 入手，能够较快掌握 mapbox-gl 的使用并投入开发实践。\n\n## 3. 快速实践\n\n下面以文章开头展示的项目为主，介绍其实战步骤。\n\n### 3.1 加载地图：\n由于使用在线地图服务和 `style` 时需要验证用户 `token`，所以在使用 `mapboxgl` 时需要先配置用户 `token`（在Mapbox官网注册用户即可获取）。\n\n```js\nimport mapboxgl from 'mapbox-gl';\nmapboxgl.accessToken = '<Your Token Here>';\n```\n\n接下来使用创建地图实例。主要配置项如下：\n\n```js\nconst myMap = new mapboxgl.Map({\n  container: '<Id of Container Element>',\n  style: '<Your Style Here>',\n  center: [112.508203125, 37.97980872872457],\n  zoom: 4,\n  pitch: 0,\n  bearing: 0,\n});\n```\n\n其中，`container` 是地图容器的元素 `id`，`style` 是地图样式的 `url`，或者你自己定义的 `style`（需遵循Mapbox样式规范），`center` 是地图加载后默认的中心点位置，用以定位地图加载时的位置。`zoom` `pitch` `bearing` 分别指缩放级别、地面法线偏移角、地轴偏移角等，用以确定当前视窗所显示的地图区域和空间关系。配置项的意义均可查看官网文档。\n\n### 3.2 绘制图形\n\n这里主要介绍视频中的3D建筑、飞线动画等是如何实现的。这里以相关代码片段来介绍实践的方法。\n\n在Mapbox中绘制图形时， `layer` 和 `source` 是最重要的一组概念，后者用于存储图形的数据内容，前者则是图形在3D场景中的表现（图层）。在Mapbox中，图层一旦被创建，与其同名（`id`相同）的数据源源（即`source`）也必然被创建。反之，也可以在创建source后再创建一个图层使用这个已创建的数据源，这时数据源与图层间并不要求同名。而我们通过改变数据来驱动图形变化，便是才去的第二种方式：\n\n```js\n// 创建id为buildings的数据源\nmyMap.addSource('buildings', {\n type: 'geojson',\n data: '<GeoJson Contents>',\n});\n\n// 使用buildings的数据来绘制id为building_layer的图形\nmyMap.addLayer({\n  id: 'building_layer',\n  type: 'fill-extrusion',\n  source: 'buildings',\n  ...<Other Options>,\n});\n```\n\n基于上面的方式，当数据改变时，我们只需要重设数据源的数据，即可驱动图层重绘：\n\n```js\nif (myMap.getLayer('building_layer')) {\n  myMap.getSource('buildings').setData(<New GeoJson Contents>);\n}\n```\n\n至于3D效果及动画的具体实现，这里给出两个官网上的示例，相信大家能一目了然：\n\n> i. [用3D形式呈现建筑](https://www.mapbox.com/mapbox-gl-js/example/3d-buildings/) \n> ii. [给路径中的一个点添加动画效果](https://www.mapbox.com/mapbox-gl-js/example/animate-point-along-route/)\n\n### 3.3 图形交互\n\nMapbox提供的交互方法是比较灵活的，活学活用API文档便能实现各种炫酷、实用的交互效果。比如：使用\n `myMap.on('zoom', callback)` 可以将图形与地图的缩放相绑定，当缩放系数小于某个值时，可以隐藏掉一些图形元素：\n\n```js\nmyMap.on('zoom', () => {\n  if (myMap.getZoom() <= 4) {\n    myMap.setLayoutProperty('building_layer', 'visibility', 'none');\n  } else {\n    myMap.setLayoutProperty('building_layer', 'visibility', 'visible');\n  }\n});\n```\n\n再比如，连续调用 `myMap.flyTo()` 的方法使视图在地图上按照一定的轨迹缓慢移动，可以给用户一种模拟飞行的体验。视频中的自动巡视的效果正是这样实现的。\n\n诸如 `click` `mouseover` `popup` 等效果，官网文档中的示例已经具体呈现，这里就不详细展开了。\n\n### 3.4 tiles-server的本地化\n由于 Mapbox 地图服务使用 MBTiles 存储数据，目前很多地图服务都接受了这套标准（如：OSM，Open Street Map）。所以可以通过搭建自己的 tiles-server 以替代直接使用 Mapbox 的在线地图服务。\n\n这样做的好处是显而易见的：一是可以通过负载均衡等手段提高数据接口的访问速度，有效提高数据的加载速度；一是保障应用能在零带宽的环境下仍能有效部署和使用。\n\n这里墙裂安利一个docker开源镜像：openmaptiles-server ，在其 [官网](https://openmaptiles.com/server/) 和 [dockerhub](https://hub.docker.com/r/klokantech/openmaptiles-server/) 上均可下载。个人认为其最大的亮点在于——即使不了解内部实现，也不影响其使用。\n\n![openmaptiles.com](http://upload-images.jianshu.io/upload_images/590155-007937c011da1d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n运行 tiles-server 服务的 docker 命令如下：\n\n```bash\n$ docker run --rm -it -v $(pwd):/data -p 8080:80\n```\n\n然后剩下来需要做的事情就是打开其导航页面 [http://localhost:8080/](http://localhost:8080/)（端口号取决于你的启动命令），然后跟着页面上的提示一步一步设置就好了（最后一步设置后会从OSM走动下载地图，所以一开始你不用担心数据从哪来），完全是傻瓜式的部署。\n\n## 4. 性能调优\n在 Mapbox GL 实践的过程中，发现了一些影响应用整体性能的因素，故而在此陈述一番，为之后填坑的童鞋提供一些经验：\n\n4.1 使用geo数据（如 GeoJson 格式数据）来定义图形的时候，若数据量过大，则会拖慢数据加载的速度，此时可考虑：\n\n* i. 在 http 请求前后对数据进行合理的压缩和解压，以尽可能节省 http 请求传输的数据量；\n* ii. 条件允许的情况下，可将一组数据分片加载，以空间换时间。\n\n4.2 在 Mapboox 中绘制的图层不宜过多，一是不方便管理（当然，github上有很多管理Mapbox图层的第三方工具），一是图层过多会明显降低GL的渲染和响应性能。所以在绘制图形前，可以先考虑一下图层的划分，以最少的图层实现尽可能多的效果。\n\n4.3 数据量相同的情况下，使用 `mapboxgl.Marker` 来添加标记，其性能不如使用 `type` 为 `symbol` 类型的图层来添加标记。原因在于前者生成的标记是一个个 DOM 元素，如果你可以想象在一个 web 页面中同时操作成百上千个 DOM 节点会是什么结果，那么你或许能明白我的建议。\n\n## 5. 一点总结\n最后，在此总结下个人对 Mapbox 的一些感观。\n\nMapbox 的产品定位是随时随地的 GIS（跨平台、应用），它为我们提供了一系列的简单操作的 API，使得 GIS 开发变得灵活而有趣。尤其对于开发 GIS 类型的数据可视化应用，Mapbox 是绝佳的选择。\n\n然而，如果你只是为了那些绚丽的 3D 效果的话，或许选择专门的框架更为合适。\n"},{"title":"amap-building-crawler 高德地图3D建筑信息爬虫项目","tag":["nodejs","爬虫","GIS","geojson"],"time":"2017-10-07 23:34:00","url":"/post/2017-10-07T23:34:00_amap-building-crawler","thumb":"/contents/2017-10-07T23:34:00_amap-building-crawler/thumb.jpg","content":"[amap-building-crawler](https://github.com/parksben/amap-building-crawler)\n\nA crawler project for fetching 3d building data from amap and tramsform its to GeoJSON.<br>\n高德地图3D建筑信息爬虫项目，用于爬取高德地图的 3D 建筑物数据，并将其转存为 GeoJSON 数据格式\n\n\n## Doc\n\n* Clone remote codes to local, then use the `yarn` command to install the project in local directory.\n\n* Execute `mkdir dist` in the project root directory (do not need to do this if the directory already exists).\n\n* Rewrite the latitude and longitude range in `index.js` file where you want to crawl the data (upper left corner & bottom right corner).\n\n```js\nconst lnglatRange = [\n  [118.01307678222655, 24.596143627409358],\n  [118.15830230712889, 24.452462684995407],\n];\n```\n\n* Execute `yarn start` in the project root directory, the retrieved data will be stored in the `dist` directory as a `.geojson` file.\n\n## 说明\n\n* clone 代码到本地，根目录使用 `yarn` 命令安装项目\n\n* 项目根目录下执行 `mkdir dist`（若目录已存在则不需要）\n\n* 修改 `index.js` 文件中需要爬取的坐标经纬度范围：\n\n```js\n// 需要爬取的经纬度范围（左上角、右下角）\nconst lnglatRange = [\n  [118.01307678222655, 24.596143627409358],\n  [118.15830230712889, 24.452462684995407],\n];\n```\n\n* 项目根目录下执行 `yarn start`，爬取的 `.geojson` 数据将存储到 `dist` 目录下\n"},{"title":"rgb-color-utils 又一个前端RGB颜色小工具","tag":["前端","npm包","工具"],"time":"2017-11-01 01:07:00","url":"/post/2017-11-01T01:07:00_rgb-color-utils","thumb":"/contents/2017-11-01T01:07:00_rgb-color-utils/thumb.jpg","content":"[项目git仓库](https://github.com/parksben/rgb-color-utils)\n\nA simple utils library for RGB colors which provides some convenient methods such as color interpolation, gradient generation, etc.\n\n## Installation\n```\nnpm install rgb-color-utils\n```\nor\n\n```\nyarn add rgb-color-utils\n```\n\n## Example Usage\n\n```js\nimport { parseColor, interpolate, gradientColor } from 'rgb-color-utils';\n\nconst colorList = parseColor('#cdab85'); // [205, 171, 133]\nconst newColor = interpolate('rgb(0, 23, 148)', '#febab5', 0.5); // '#7f69a5'\nconst colorMap = gradientColor('#bca380', '#00f', 4); // ['#bca380', '#8d7aa0', '#5e52c0', '#2f29df']\n```\n\n## API\n\n### parseColor(color)\n\n- `color` one RGB/HEX color string (`rgb(0, 23, 148)` or `#bf0081`)\n\n### interpolate(from, to, step)\n\n- `from` the starting position RGB/HEX color string (`rgb(0, 23, 148)` or `#bf0081`)\n- `to` the end position color string\n- `step` the normalized value (between 0 and 1) of the interpolation. A step of `0.5` would be the middle of `from` and `to`\n\n### gradientColor(from, to, length)\n\n- `from` the starting position RGB/HEX color string (`rgb(0, 23, 148)` or `#bf0081`)\n- `to` the end position color string\n- `length ` the length of the gradient colors array.\n\n## License\n\nMIT License\n"},{"title":"快速搭建你的 github pages 个人博客 —— 基于 Create-React-App 的单页面应用实践","tag":["前端","nodejs","react"],"time":"2018-01-28 10:26:17","url":"/post/2018-01-28T10:26:17_create-a-react-blog","thumb":"/contents/2018-01-28T10:26:17_create-a-react-blog/thumb.jpg","content":"相信各位github资深玩家们都有自己基于 `github pages` 搭建的个人站点。官方推荐的静态站点生成器是 `Jekyll`，关于 `Jekyll` 的使用感兴趣的各位请自行 google，这里就不赘述了。本文主要介绍下基于 `Create-React-App` 搭建个人博客的相关实践，可能更适合做前端开发的伙伴。\n\n![github pages](/contents/2018-01-28T10:26:17_create-a-react-blog/thumb.jpg)\n\n`github pages` 是 `github` 推出的静态站点服务，主要的用途在于使用你在 `github` 仓库中的代码构建你自己的静态站点，为用户提供 `github.io` 二级域名，您也可以通过添加DNS的 `CNAME` 记录来绑定自己的域名。\n\n`github pages` 最简单粗暴的方法就是直接往 github 上方静态页面了，创建一个名为 `[您的github账号名].github.io` 的github仓库，将您的index.html页面代码扔进master分支，就可以直接通过 `https://[您的github账号名].github.io` 访问到您的站点了。\n\n对于一个简单的个人博客站点来说，存在以下基本功能特性：\n\n* 文章的新增、编辑、一键发布\n* 文章的分类、归档yarn\n* 风格良好的博客样式\n* 评论、SEO等功能\n\n下面介绍基于React如何实现一个简单的静态博客。\n\n## 1. 创建一个 React 项目\n\n使用 Create-React-App（以下简称CRA） 的generator创建一个React前端项目骨架。对此项目进行一定改造以方便我们日常的开发和使用习惯：\n\n* 使用`react-app-rewired`来调整CRA中webpack的配置\n  * 对CRA的webpack配置感兴趣的童鞋可以看看[这篇文章](https://zhaozhiming.github.io/blog/2018/01/08/create-react-app-override-webpack-config/)\n* 使用`core-js`对浏览器版本进行向下兼容\n* 通过编写不同的React容器组件（container）来实现不同的页面，通过统一的json结构来配置应用的页面路由\n* 使用蚂蚁金服的`antd`设计语言（React组件）快速实现业务UI\n* 使用`axios`实现前后端的数据请求\n\n个人改造后的项目代码在[这里](https://github.com/parksben/react-spa-app)，您可以直接fork或者down下来使用。\n\n## 2. 使用 markdown 搞定你的文章\n### 2.1 用于新建文章的交互式命令行（基于 inquirer）\n\n一般的静态博客系统（如gatsby），会给用户提供一个用于创建新文章的交互式命令行，效果大致如下：\n\n![readline](/contents/2018-01-28T10:26:17_create-a-react-blog/readline.gif)\n\n类似功能可以使用nodejs中[readline模块](https://nodejs.org/dist/latest-v8.x/docs/api/readline.html)的原生方法来实现。这里推荐一个第三方工具：[inquirer](https://github.com/SBoudrias/Inquirer.js)，本质上是对readline模块进行了增强，提供了很多实用的方法用于交互式命令行开发，实现的用户界面（命令行）也比较友好。\n\n对于上面GIF示例的功能，其代码实现如下：\n\n```js\n// newPost.js\n\nconst inquirer = require('inquirer');\nconst moment = require('moment');\n\nconst questions = [\n  {\n    type: 'input',\n    name: 'post_name',\n    message: '请输入您的文章别名（用于创建文章目录，仅限英文，单词间用短横杠‘-’连接）：',\n    validate: value => {\n      if (/(\\.|\\*|\\?|\\\\|\\/)/gi.test(value)) {\n        return '文章别名不得包含特殊符号（.*?\\\\/），请重新输入↑↑';\n      }\n\n      if (/(([A-z]+-)+)?[A-z]+/gi.test(value)) {\n        return true;\n      }\n\n      return '文章别名不合法，请重新输入↑↑';\n    },\n    filter: value => value.replace(/\\s+/gi, '-'),\n  },\n  {\n    type: 'input',\n    name: 'create_at',\n    message: '请输入文章的发布时间（或者按回车键使用默认值）：',\n    default: () => {\n      return moment().format('YYYY-MM-DDThh:mm:ss');\n    },\n    validate: value => {\n      if (/\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d/gi.test(value)) {\n        return true;\n      }\n\n      return '时间格式不合法，请重新输入↑↑';\n    },\n  },\n];\n\ninquirer\n  .prompt(questions)\n  .then(answers => {\n    // 获取用户输入\n    const { post_name, create_at } = answers;\n\n    /* 此处做一些命令行反馈和过程性的工作 */\n    /* （如：提示用户输入是否合法、创建文章对应的目录和文件等等） */\n  })\n  .catch(err => {\n    /* 异常处理 */\n  });\n```\n\n如是，将此node脚本添加到项目`package.json`的`scripts`中（如：`new-post: \"node newPost.js\"`），即可通过`yarn new-post`命令运行。\n\n### 2.2 md 转 html（基于 react-markdown）\n\n为使用markdown文档来编辑、存储博客的文章内容，需要将md文档内容转换为react的JSX对象以渲染到网页中。在此推荐使用[react-markdown](https://github.com/rexxars/react-markdown)，功能很6，作者维护得也比较勤。\n\n使用方式如下：\n\n```js\nimport ReactMarkdown from 'react-markdown';\n\n<ReactMarkdown source={'# 这是文章标题\\n\\n'} />\n// <h1>这是文章标题</h1>\n```\n\n### 2.3 代码块的语法高亮\n\nreact-markdown提供了一个renderers属性，用户可以传入一系列renderer组件来自定义文章中一些内容的渲染方式（有兴趣的童鞋可以看下包作者对[默认renderer的实现](https://github.com/rexxars/react-markdown/blob/master/src/renderers.js)）。\n\n如：自定义md中图片的渲染方式（用法如下）。\n\n```js\n// 传入renderer的方式\n<ReactMarkdown\n  source={'[md文本内容]'}\n  renderers={{\n    image: ImageRenderer,\n  }}\n/>\n```\n\n```js\n// ImageRenderer的实现\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\nclass ImageRenderer extends Component {\n  static propTypes = {\n    src: PropTypes.string.isRequired,\n  };\n\n  render() {\n    return (\n      <img\n        className=\"post-content-image\"\n        src={this.props.src}\n        alt={this.props.src}\n      />\n    );\n  }\n}\n\nexport default ImageRenderer;\n```\n\n与此类似，我们可以通过传入一个自定义的renderer来实现文章中代码块的语法高亮。名为`CodeBlock`的renderer实现如下：\n\n```js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { highlight, languages } from 'prismjs';\nimport ReactHtmlParser from 'react-html-parser';\nimport 'prismjs/themes/prism.css';\n\nexport class HtmlComponent extends Component {\n  static propTypes = {\n    html: PropTypes.string.isRequired,\n  };\n\n  render() {\n    return ReactHtmlParser(this.props.html);\n  }\n}\n\nexport class CodeBlock extends Component {\n  static propTypes = {\n    literal: PropTypes.string.isRequired,\n    language: PropTypes.string.isRequired,\n  };\n\n  render() {\n    const html = highlight(this.props.literal, languages[this.props.language]);\n    const cls = `language-${this.props.language}`;\n\n    return (\n      <pre className={cls}>\n        <code className={cls}>\n          <HtmlComponent html={html} />\n        </code>\n      </pre>\n    );\n  }\n}\n\nexport default CodeBlock;\n```\n\n此处用到了[prismjs](http://prismjs.com/)和[react-html-parser](https://github.com/wrakky/react-html-parser)两个npm包，前者用于将代码文本转化为html文本，后者用于将html文本转化为React的JSX对象以传入React组件（这样做比直接使用[dangerouslySetInnerHTML](https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml)属性更安全些）。\n\n## 3. 文章分类\n\n一个友好的站点肯定少不了导航菜单（或文章的分类菜单），本人的实现方式是直接使用文章的“标签”来进行分类统计，并生成站点的顶部导航，效果如下：\n\n![navigator](/contents/2018-01-28T10:26:17_create-a-react-blog/nav-top.png)\n\n为此，需要撰写一定的脚本实现文章的分类统计和打包，个人的实现方式是将统计结果和文章内容各自打包为json文件，通过前端组件请求数据并加载。\n\n导航栏组件的具体实现如下：\n\n```js\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Link } from 'react-router-dom';\nimport { Dropdown, Menu, Icon } from 'antd';\nimport { randomId } from 'utils';\nimport './style.css';\n\nexport class Header extends Component {\n  static propTypes = {\n    data: PropTypes.array,\n    activeTag: PropTypes.string,\n  };\n\n  static defaultProps = {\n    data: [{ tag: '前端', count: 5 }],\n    activeTag: '',\n  };\n\n  constructor(props) {\n    super(props);\n    this.navTotal = 6;\n  }\n\n  renderMore() {\n    if (this.props.data.length <= this.navTotal) {\n      return false;\n    }\n\n    const subNavItems = this.props.data.slice(this.navTotal).map(t =>\n      <Menu.Item key={`sub_nav_${randomId()}`}>\n        <Link\n          to={t.linkTo || `/tag/${t.tag}`}\n          className={`ant-dropdown-link ${this.props.activeTag === t.tag\n            ? 'active'\n            : ''}`}\n          key={`nav_top_${randomId()}`}>\n          {t.tag}（{t.count}）\n        </Link>\n      </Menu.Item>\n    );\n\n    const SubNav = (\n      <Menu>\n        {subNavItems}\n      </Menu>\n    );\n\n    const DropDownBtn = (\n      <Dropdown overlay={SubNav} key={`nav_top_${randomId()}`}>\n        <div className=\"header-nav-item\">\n          更多分类 <Icon type=\"down\" />\n        </div>\n      </Dropdown>\n    );\n\n    return DropDownBtn;\n  }\n\n  renderTop5() {\n    const items = this.props.data.slice(0, this.navTotal - 1).map(t =>\n      <Link\n        className={`header-nav-item ${this.props.activeTag === t.tag\n          ? 'active'\n          : ''}`}\n        to={t.linkTo || `/tag/${t.tag}`}\n        key={`nav_top_${randomId()}`}>\n        {!t.linkTo ? `${t.tag}（${t.count}）` : t.tag}\n      </Link>\n    );\n\n    return (\n      <div className=\"header-nav\">\n        {items}\n        {this.renderMore()}\n      </div>\n    );\n  }\n\n  render = () => this.renderTop5();\n}\n\nexport default Header;\n```\n\n大家可以根据实际需要实现自己的文章打包方式（这里就不奉上我的脚本了😝）。\n\n## 4. 更多功能\n\n对于个人博客来说，到这里为止还有很多功能没有实现，这里偷个懒，奉上一些相关的链接吧：\n\n### 4.1 关于文章评论\n\n* [在github pagess中加入Disqus评论系统](http://www.forestofhorizon.com/notesofstudy/2015/12/01/adding-disqus-to-github-pages/)\n* [使用 GitHub Issues 搭建评论系统](https://imsun.net/posts/gitment-introduction/)\n\n### 4.2 关于文章结构树\n\n* [TreeMDown](https://github.com/hollodotme/TreeMDown)\n* [markdown-tree](https://github.com/hughsk/markdown-tree)\n\n我最近写了一个md文章的目录组件，各位大佬高兴的话可以赏个star:\n\n* [Markdown-Navbar](https://github.com/parksben/markdown-navbar)\n\n## 5. 发布你的个人静态站点\n### 5.1 部署到 github pages（基于 gh-pages）\n\nCRA针对github pages用途专门推荐了一个包：[gh-pages](https://github.com/tschaub/gh-pages)，使用方法如下：\n\n（1）修改项目的`package.json`文件，添加homepage属性：\n\n```\n\"homepage\": \"https://parksben.github.io\",\n```\n\n（2）项目安装`gh-pages`依赖后，在`package.json`中添加如下配置：\n\n```\n  \"scripts\": {\n+   \"predeploy\": \"npm run build\",\n+   \"deploy\": \"gh-pages -d build\",\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n```\n\n（3）将本地代码上传到github博客仓库的某个分支（只要不是master分支就行），然后执行：\n\n```\nyarn deploy\n```\n\ngh-pages会将CRA项目build到仓库的master分支，然后，你就可以访问你的站点了（有关 CRA 项目部署到 github pages 的详细描述可以看[这里](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#github-pages)）。\n\n### 5.2 如何兼容 React 的客户端路由（一种比较 hack 的方法）\n\n单页面应用一般需要设置服务端路由，将应用的所有页面路径都重定向到index.html，而github pages并没有这样的默认设置。\n\n因而，当你使用React的客户端路由（React的createBrowserHistory方法创建前端路由）时，除根路径以外的页面，github都会返回自己的404页面。\n\n为此，CRA项目提供了一种比较hack的方法来支持React的客户端路由（通过操作window.history来强行匹配url）。也算是一种奇技淫巧吧☺️。\n\n（1）在CRA项目的public目录下添加一个`404.html`，其内容如下：\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"utf-8\">\n    <title>矮大紧的日常 | parksben's blog</title>\n    <script type=\"text/javascript\">\n      var segmentCount = 0;\n      var l = window.location;\n      l.replace(\n        l.protocol + '//' + l.hostname + (l.port ? ':' + l.port : '') +\n        l.pathname.split('/').slice(0, 1 + segmentCount).join('/') + '/?p=/' +\n        l.pathname.slice(1).split('/').slice(segmentCount).join('/').replace(/&/g, '~and~') +\n        (l.search ? '&q=' + l.search.slice(1).replace(/&/g, '~and~') : '') +\n        l.hash\n      );\n    </script>\n  </head>\n  <body>\n  </body>\n</html>\n```\n\n（2）在`index.html`的head中添加如下代码：\n\n```html\n<script type=\"text/javascript\">\n  (function(l) {\n    if (l.search) {\n      var q = {};\n      l.search.slice(1).split('&').forEach(function(v) {\n        var a = v.split('=');\n        q[a[0]] = a.slice(1).join('=').replace(/~and~/g, '&');\n      });\n      if (q.p !== undefined) {\n        window.history.replaceState(null, null,\n          l.pathname.slice(0, -1) + (q.p || '') +\n          (q.q ? ('?' + q.q) : '') +\n          l.hash\n        );\n      }\n    }\n  }(window.location))\n</script>\n```\n\n大功告成，你的github站点支持React的客户端路由了。\n\n除此之外，也可以改为使用`createHashHistory`方法来创建客户端路由，这样前端路由就与服务端路由没多大关系了，不过url里面一串hash毕竟不够优雅。\n\n有兴趣了解奇技淫巧的童鞋，可以点[这里](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#notes-on-client-side-routing)。\n\n### 5.3 部署到自己的服务\n\n与CRA项目的生产环境部署方式一样：\n\n* 线上执行 yarn build 命令，站点的所有静态资源将打包到 build 目录下\n* 将你的站点入口配置到 build 目录下\n\n## 6. 项目参考（源码奉上）\n\n![parksben.github.io](/contents/2018-01-28T10:26:17_create-a-react-blog/my-blog.png)\n\n这是[我的github博客](https://parksben.github.io/)（基于上述过程实现的静态站点），感兴趣的伙伴可以[点击这里](https://github.com/parksben/parksben.github.io)查看项目源码，觉得有用也可以fork或star一下下。\n"},{"title":"Markdown-Navbar","tag":["markdown","navbar","react","前端"],"time":"2018-02-25 05:28:08","url":"/post/2018-02-25T05:28:08_markdown-navbar","thumb":"/contents/2018-02-25T05:28:08_markdown-navbar/thumb.jpg","content":"Best markdown navigation bar for React.\n\n[git repo](https://github.com/parksben/markdown-navbar)\n\n## Install\n\n```\nyarn add markdown-navbar\n```\nor\n\n```\nnpm install markdown-navbar\n```\n\n## Usage\n\n```js\nimport MarkNav from 'markdown-navbar';\nimport 'markdown-navbar/dist/navbar.css';\n\nconst content = '## Heading One...\\n\\n## Heading Two...\\n';\n\n<MarkNav\n  className=\"article-menu\"\n  source={content}\n  headingTopOffset={80}\n/>\n```\n\n## Screenshots\n\n![Screenshots](/contents/2018-02-25T05:28:08_markdown-navbar/markdown-navbar.gif)\n\n## Options\n\n|property|type|default value|use|\n|:-:|:-:|:-:|:-:|\n|className|string|\"\"|The className that defines the outermost container of navbar|\n|source|string|\"\"|Markdown text content|\n|headingTopOffset|number|0|Anchor relative to the top of the window displacement (for the anchor jump)|\n|ordered|boolean|true|Whether the title contains a numerical prefix, such as: `1. 2. 2.2`|\n\n## License\n\n`Markdown-Navbar` is released under the MIT license.\n"},{"title":"然并卵：BF 科普 & BF 解释器的 JS 实现","tag":["brainFuck","其他"],"time":"2018-08-12 21:54:38","url":"/post/2018-08-12T21:54:38_brainfuck-interpreter-of-js","thumb":"/contents/2018-08-12T21:54:38_brainfuck-interpreter-of-js/thumb.jpg","content":"![图片来源：google 搜索](/contents/2018-08-12T21:54:38_brainfuck-interpreter-of-js/thumb.jpg)\n\n最近在 [Codewars](https://www.codewars.com/ )上做练习，某道题的内容是实现一个 brainFuck（简称BF语言） 解释器（c/python/js等等均可）。动手实践的过程还是很有趣的，中间也遇到了各种各样的问题，最终通过测试，代码也比较接近目前的 JS 高分 solution。这篇文章准备聊聊相关的一些知识和实现的细节。\n\n## “脑洞大开”的语言 —— BF 简介\n\nBrainfuck（后文以简写BF指代），单是名字就很容易让人脑洞大开，有种不可描述的“哲学”韵味。所以如果你忍不住 google 一下相关图片的话，你会可能搜到类似下面的图片：\n\n![图片来源：google 搜索](/contents/2018-08-12T21:54:38_brainfuck-interpreter-of-js/bf_brief.jpeg)\n\n**画面是不是已经很生动了？**\n\nBF 字面上的含义已经暗示了这是一种不太直观和容易阅读的语言，当然，在当下也不会是一种通用语言。她属于 Esolang（全称 Esoteric programming language，直译：深奥的编程语言） 的范畴。\n\nBF诞生于上世纪30年代，曾运用于早期的 PC（Amiga），想详细了解的童鞋可以浏览 [维基百科](https://zh.wikipedia.org/wiki/Brainfuck)。\n\n**BF 在当下有什么应用场景呢？**\n\n我想，对一个吃瓜群众来说，了解了它，对写作 **逼格** 和 **脑力** 的提升是很有用的。BF 具有**极简主义**（搞设计的童鞋的不妨了解下下）和**功能齐全**（图灵完全）的特点，旨在为用户带来困惑和挑战，丰富劳动人民的业余生活。\n\n## 8 种运算符及其操作\n\nBF 作为一种极简的计算机语言，仅有8种运算符，分别为: `<` `>` `+` `-` `,` `.` `[` `]`，其功能对照如下表所示：\n\n| 指令 | 含义 |\n|:---:|:---:|\n| `<` | 指针减一（指针左移） |\n| `>` | 指针加一（指针右移） |\n| `+` | 指针指向的字节的值加一（当前单元的数值+1） |\n| `-` | 指针指向的字节的值减一（当前单元的数值-1） |\n| `,` | 输入内容到指针指向的单元（输入一个字符，将其ASCII码保存到当前指针所指单元） |\n| `.` | 将指针指向的存储单元的内容作为字符输出（将ASCII码输出为字符） |\n| `[` | 如果指针指向的存储单元为零，向后跳转到对应的 `]` 指令处 |\n| `]` | 如果指针指向的存储单元不为零，向前跳转到对应的 `[` 指令处 |\n\nBF基于一个简单的机器模型，除了八个指令，这个机器还包括：一个以字节为单位、被初始化为零的数组、一个指向该数组的指针(初始时指向数组的第一个字节)、以及用于输入输出的两个字节流。\n\n对 BF 比较有意思的比拟可以是这样的：\n\n1. 如果把机器内存看成是一个无限长的“小火车”（类似于`Array`或`List`的数据结构）,每个车厢（存储单元）里面的货物默认都是数字 `0`，列车上仅有一个列车员（数据指针）；\n2. `<>` 相当于列车员在车厢间进行移动，只有当列车员在某节车厢时，才能对车厢的货物进行操作；\n3. `+-` 相当于列车员对当前所在车厢的货物进行增减；\n4. `,` 相当于列车在装货，列车员将当前所在车厢的货物替换为货运站输入的单批次货物（一个字符的ASCII码）；\n5. `.` 会将当前车厢里的货物名称（单个字符）出来；\n6. `[]` 相当于列车员在满足条件的两节车厢间来回移动；\n\n这里要注意的是，数组的每个单元都是一个字节大小；`-` 命令允许溢出，它可以用 255 个 `+` 命令来代替。例如，当某个存储单元的值为 255 时，其执行指令 `+` 的结果为 0。类似的， 0 执行指令 `-` 的结果为 255.\n\n## 与通用语言的类比\n\n据此，BF的运算符与通用语言的类比如下（以C语言为例）：\n\n| BrainFuck | C |\n|:-:|:-:|\n| `<` | `--ptr;` |\n| `>` | `++ptr;` |\n| `+` | `++*ptr;` |\n| `-` | `--*ptr;` |\n| `,` | `*ptr = getchar();` |\n| `.` | `putchar(*ptr);` |\n| `[` | `while (*ptr) {` |\n| `]` | `}` |\n\n## BF 解释器的 JS 函数实现\n\n### 代码奉上：\n\n```js\nfunction brainLuck(code, input) {             // @1\n  const inputChars = input.split('');         // @2\n\n  const codes = code.split('');               // @3\n  let codeIdx = 0;\n\n  const arr = [];                             // @4\n  let arrIdx = 0;\n  let outputStr = '';                         // @5\n\n  while (codeIdx < code.length) {             // @6\n    const ops = codes[codeIdx];\n\n    const handleLeftBracket = () => {         // @7\n      if (~~arr[arrIdx] === 0) {\n        let cnt = 1;\n\n        while (cnt) {\n          codeIdx++;\n          if (codes[codeIdx] === '[') {\n            cnt += 1;\n          }\n          if (codes[codeIdx] === ']') {\n            cnt -= 1;\n          }\n        }\n      }\n    };\n\n    const handleRightBracket = () => {        // @8\n      if (~~arr[arrIdx] !== 0) {\n        let cnt = 1;\n\n        while (cnt) {\n          codeIdx--;\n          if (codes[codeIdx] === ']') {\n            cnt += 1;\n          }\n          if (codes[codeIdx] === '[') {\n            cnt -= 1;\n          }\n        }\n      }\n    };\n\n    switch (ops) {                            // @9\n      case '>':\n        arrIdx += 1;\n        break;\n      case '<':\n        arrIdx -= 1;\n        break;\n      case '+':\n        arr[arrIdx] = (~~arr[arrIdx] + 1) % 256;\n        break;\n      case '-':\n        arr[arrIdx] = (~~arr[arrIdx] || 256) - 1;\n        break;\n      case ',':\n        const iptChar = inputChars.shift();\n        arr[arrIdx] = iptChar ? iptChar.charCodeAt(0) : arr[arrIdx];\n        break;\n      case '.':\n        outputStr += String.fromCharCode(arr[arrIdx]);\n        break;\n      case '[':\n        handleLeftBracket();\n        break;\n      case ']':\n        handleRightBracket();\n        break;\n    }\n\n    codeIdx++;                               // @10\n  }\n\n  return outputStr;                          // @11\n}\n\n```\n\n### 实现思路阐述（与代码中注释的序号对应）：\n\n(1) 我们实现了一个函数 brainLuck 用以模拟 BF 语言的解释执行，函数 brainLuck 的用例如下：\n\n```js\nconst code = ',+[-.,+]';\nconst input = 'Parksben' + String.fromCharCode(255);\n\nconst output = brainLuck(code, input);\nconsole.log(output); // -> 'Parksben'\n```\n\n(2) 将输入的字符串切割为单个字符，暂存进数组 inputChars；\n\n(3) 将 BF 程序切割为单个操作符，方便遍历每个指令，用 codeIdx 作为下标进行遍历；\n\n(4) 声明一个数组 arr 用以模拟机器内存，过程产生的数值存储到此数组中；\n\n(5) 用字符串 outputStr 存储程序的输出；\n\n(6) 遍历 BF 运算符，对不同指令进行相应的操作；\n\n(7) 方法 handleLeftBracket，用以匹配到与当前 `[` 对应的 `]`（通过操作下标 codeIdx）；\n\n(8) 方法 handleRightBracket，用以匹配到与当前 `]` 对应的 `[`（通过操作下标 codeIdx）；\n\n(9) 用以处理不同指令的 switch 语句；\n\n(10) codeIdx 加一，以向前遍历 codes；\n\n(11) 程序输出；\n\n## 延伸阅读\n\n[Brainfuck: a Programming Language or a Joke?](https://vironit.com/brainfuck-a-programming-language-or-a-joke/)\n\n[丹尼尔·克里斯托法尼的一些 BF 实例](http://www.hevanet.com/cristofd/brainfuck/)\n\n[深奥的编程语言 - 维基百科](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%A5%A5%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80)\n"},{"title":"[小清新] 一段 node 脚本生成风格优雅的 Directory Tree","tag":["前端","nodejs"],"time":"2018-10-03 06:34:00","url":"/post/2018-10-03T06:34:00_make-directory-tree-with-nodejs","thumb":"/contents/2018-10-03T06:34:00_make-directory-tree-with-nodejs/thumb.jpg","content":"![via: Google image search](/contents/2018-10-03T06:34:00_make-directory-tree-with-nodejs/thumb.jpg)\n\n## 一些烦恼\n\n如果你常常在博客中插入一些文件目录结构，不免会有碰到诸如此类的问题：\n\n* 使用图片输出的话，感官上不够和谐，尤其在移动端环境下，图片内容可能会被多次转码、缩放以至于影响阅读体验。\n* 使用文本输出的话，在不同设备、编辑器下内容排版容易混乱。\n* 某一天，你想修改一下内容或者结构时，一个字符一个字符的编辑简直让人抓狂。\n* 使用文本输出的另一个毛病就是，不同设备、平台的字号、字体、字符样式都不一样。也许你写的时候觉得足够有美感，在受众的设备里却如同一坨翔。\n\n## 解决方案\n\n由于但不限于上述种种原因，自己写了一个小脚本，可以顺利地实现目录树的生成。结果被输出为html片段，通过附加CSS样式，效果远好于前几种的方式。\n\n脚本输出的 html 长这样：\n\n~~~html\n<style>\n  .parksben-is-just-one-single-doge {\n    width: 90%;\n    max-width: 640px;\n    box-sizing: border-box;\n    margin: 1em auto;\n    padding: 2em;\n    background: #333;\n    border-radius: 5px;\n    overflow: hidden;\n    font: 14px/18px Helvetica, Arial, \"Microsoft Yahei\", Verdana, sans-serif;\n    --content-color: #fff;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree {\n    color: var(--content-color);\n  }\n\n  .parksben-is-just-one-single-doge ul.tree,\n  .parksben-is-just-one-single-doge ul.tree ul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree ul {\n    margin-left: 1em;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree li {\n    margin: 0;\n    padding: 0 1em;\n    line-height: 2em;\n    font-weight: bold;\n    position: relative;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree li::before {\n    content: '';\n    display: block;\n    width: 1px;\n    height: 100%;\n    background: var(--content-color);\n    position: absolute;\n    left: 0;\n    top: 0;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree li::after {\n    content: '';\n    display: block;\n    width: 0.8em;\n    height: 1px;\n    background: var(--content-color);\n    position: absolute;\n    left: 0;\n    top: 0.9em;\n  }\n\n  .parksben-is-just-one-single-doge ul.tree li:last-child::before {\n    height: 1em;\n    bottom: 1em;\n  }\n</style>\n<div class=\"parksben-is-just-one-single-doge\">\n  <ul class=\"tree\"><li>app.css</li><li>app.js</li><li>components<ul><li>Bar3d<ul><li>index.js</li><li>shaders<ul><li>index.js</li></ul></li><li>style.css</li><li>utils<ul><li>mesh.js</li><li>webgl.js</li></ul></li></ul></li><li>Button<ul><li>index.js</li><li>style.css</li></ul></li><li>DragImg<ul><li>index.js</li><li>style.css</li></ul></li><li>PlayStarBySvg<ul><li>index.js</li><li>style.css</li></ul></li><li>PlayStarInCanvas<ul><li>index.js</li><li>style.css</li></ul></li></ul></li><li>utils<ul><li>index.js</li></ul></li></ul>\n</div>\n~~~\n\n显示的效果长这样（清新脱俗的黑白配、肥而不腻的字形，要多优雅有多风骚）：\n\n![Directory tree](/contents/2018-10-03T06:34:00_make-directory-tree-with-nodejs/directory.jpg)\n\n## 源码奉上\n\n很简单的东西，这里直接直接献上代码吧。如果确实能给大家带来一丢丢的效率，我就很欣慰了，或者大家有什么更优雅而高效的东东，不妨留言给我安利安利。\n\n~~~js\n/*\n** File:  `makeTree.js`\n** Usage: `node makeTree.js ./`\n*/\n\nconst fs = require('fs');\nconst path = require('path');\n\nfunction makeHtml(dir) {\n  const items = fs.readdirSync(dir).map(file => {\n    let str = file;\n\n    const filePath = path.join(dir, file);\n    if (fs.lstatSync(filePath).isDirectory()) {\n      str += makeHtml(filePath);\n    }\n\n    return `<li>${str}</li>`;\n  });\n\n  return `<ul>${items.join('')}</ul>`;\n}\n\nconst dirToShow = process.argv[2] || './';\nconst treeStr = makeHtml(path.join(__dirname, dirToShow.trim()));\n\nconst containerName = 'parksben-is-just-one-single-doge';\nconst htmlStr = `<style>\n  .${containerName} {\n    width: 90%;\n    max-width: 640px;\n    box-sizing: border-box;\n    margin: 1em auto;\n    padding: 2em;\n    background: #333;\n    border-radius: 5px;\n    overflow: hidden;\n    font: 14px/18px Helvetica, Arial, \"Microsoft Yahei\", Verdana, sans-serif;\n    --content-color: #fff;\n  }\n\n  .${containerName} ul.tree {\n    color: var(--content-color);\n  }\n\n  .${containerName} ul.tree,\n  .${containerName} ul.tree ul {\n    list-style-type: none;\n    margin: 0;\n    padding: 0;\n  }\n\n  .${containerName} ul.tree ul {\n    margin-left: 1em;\n  }\n\n  .${containerName} ul.tree li {\n    margin: 0;\n    padding: 0 1em;\n    line-height: 2em;\n    font-weight: bold;\n    position: relative;\n  }\n\n  .${containerName} ul.tree li::before {\n    content: '';\n    display: block;\n    width: 1px;\n    height: 100%;\n    background: var(--content-color);\n    position: absolute;\n    left: 0;\n    top: 0;\n  }\n\n  .${containerName} ul.tree li::after {\n    content: '';\n    display: block;\n    width: 0.8em;\n    height: 1px;\n    background: var(--content-color);\n    position: absolute;\n    left: 0;\n    top: 0.9em;\n  }\n\n  .${containerName} ul.tree li:last-child::before {\n    height: 1em;\n    bottom: 1em;\n  }\n</style>\n<div class=\"${containerName}\">\n  <ul class=\"tree\">${treeStr.slice(4)}\n</div>\n`;\n\nfs.writeFileSync(path.join(__dirname, 'tree.html'), htmlStr, 'utf8');\nconsole.log('==> Done: the directory tree is saved to ./tree.html');\n~~~\n\n## 局限性\n\n这样做解决了一部分问题，至少往自己的博客文章里放问题不大。\n\n但还有很大的局限性，比如对于掘金、简书、知乎这样的第三方页面，直接插 CSS 很难完全覆盖已有的样式，工作也很繁琐。\n\n个人想到的另一个办法是把内容输出成 svg，这样，在保证样式和内容正确性的同时，读者也可以直接 copy 上面的文字。这个我打算下一步弄下，可行的话再把代码 push 出来。\n\n## 后续\n\n最后再废话一两句，最近有很多东西感觉可以分享出来，比如下一篇文章我准备写写 webGL 的一些内容，或者地图开发方面的内容。先在这里挖个坑，好逼迫一下自己。\n\n好长一段时间没写文章了，加班、通宵什么的都不是借口，大好时光可不能就此荒废。\n"},{"title":"可实现B站 蒙版弹幕 效果的前端组件 —— barrage-ui","tag":["前端","弹幕","UI组件","npm"],"time":"2019-01-15 06:01:11","url":"/post/2019-01-15T06:01:11_barrage-ui","thumb":"/contents/2019-01-15T06:01:11_barrage-ui/thumb.jpg","content":"Best and lightest barrage component for web UI.\n\n适用于 web 端用户界面和播放器的轻量级弹幕组件\n\n![Demo](https://github.com/parksben/barrage/raw/master/images/barrage.gif)\n\n## 用途\n\n- 为你的 视频播放器、图片浏览器 等元素挂载弹幕动画\n- 用于实现 B 站(bilibili.com) 风格的 **蒙版弹幕** 效果\n\n## 安装\n\n```\nyarn add barrage-ui\n```\n\n或\n\n```\nnpm install --save barrage-ui\n```\n\n## 快速开始\n\n```js\nimport Barrage from 'barrage-ui';\nimport example from 'barrage-ui/example.json'; // 组件提供的示例数据\n\n// 加载弹幕\nconst barrage = new Barrage({\n  container: 'barrage', // 父级容器或ID\n  data: example, // 弹幕数据\n  config: {\n    // 全局配置项\n    duration: 20000, // 弹幕循环周期(单位：毫秒)\n    defaultColor: '#fff', // 弹幕默认颜色\n  },\n});\n\n// 新增一条弹幕\nbarrage.add({\n  key: 'fctc651a9pm2j20bia8j', // 弹幕的唯一标识\n  time: 1000, // 弹幕出现的时间(单位：毫秒)\n  text: '这是新增的一条弹幕', // 弹幕文本内容\n  fontSize: 24, // 该条弹幕的字号大小(单位：像素)，会覆盖全局设置\n  color: '#0ff', // 该条弹幕的颜色，会覆盖全局设置\n});\n\n// 播放弹幕\nbarrage.play();\n```\n\n## 初始化参数\n\n创建弹幕实例时，需要传入的初始化参数如下：\n\n|       参数       |                                    数据类型                                    |              默认值              | 说明                                                                                                                                                           |\n| :--------------: | :----------------------------------------------------------------------------: | :------------------------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n|    container     |                                 string/element                                 |          必传，无默认值          | 弹幕的挂载点                                                                                                                                                   |\n|       data       |                                     array                                      |                []                | 弹幕数据                                                                                                                                                       |\n|      config      |                                     object                                     |          详见全局配置项          | 详见[全局配置项](#全局配置项)                                                                                                                                  |\n|       mask       | string/[ImageData](https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData) |         string/ImageData         | 蒙版图像，用于实现蒙版弹幕效果，详见[蒙版弹幕](#蒙版弹幕)                                                                                                      |\n|   beforeRender   |                                    function                                    | (ctx, progress, animState) => {} | 帧渲染前的回调，函数实参分别为：<br/>**`ctx`** canvas 画布的上下文<br/>**`progress`** 动画的播放进度(毫秒)<br/>**`animState`** 动画状态: 'paused' 或 'playing' |\n|   afterRender    |                                    function                                    | (ctx, progress, animState) => {} | 帧渲染后的回调，函数实参分别为：<br/>**`ctx`** canvas 画布的上下文<br/>**`progress`** 动画的播放进度(毫秒)<br/>**`animState`** 动画状态: 'paused' 或 'playing' |\n| overlapOptimized |                                    boolean                                     |              false               | 弹幕装填时是否启用布局优化，以尽可能避免使相邻时间的弹幕重叠                                                                                                   |\n\n其中，`container` 参数在初始化实例时必传，其他参数为可选，数据类型及默认值如上表所示。\n\n## 全局配置项\n\n### 配置项及默认值\n\n弹幕的所有全局配置项及默认值如下：\n\n```js\n{\n  duration: -1, // 弹幕动画的循环周期，-1 表示不循环播放\n  speed: 100, // 弹幕的运动速度\n  fontSize: 24, // 文字大小，单位：像素\n  fontFamily: 'Microsoft Yahei', // 字体，默认值：微软雅黑\n  textShadowBlur: 1.0, // 字体阴影扩散，有效值 >= 0\n  opacity: 1.0, // 透明度，有效值 0-1\n  defaultColor: '#fff', // 默认颜色，与 CSS 颜色属性一致\n}\n```\n\n### 更新配置项\n\n如果你的弹幕实例已创建或者正在播放，可以通过 `.setConfig()` 方法进行实时更新：\n\n```js\n// 更新全局透明度\nbarrage.setConfig({ opacity: 0.5 });\n```\n\n## 弹幕数据\n\n### 结构与内容\n\n弹幕数据集为一个对象数组。每个数组元素对应一条弹幕记录，其结构如下：\n\n```js\n{\n  key: 'fctc651a9pm2j20bia8j',\n  createdAt: '2019-01-13T13:34:47.126Z',\n  time: 1200,\n  text: '我膨胀了',\n  fontFamily: 'SimSun',\n  fontSize: 32,\n  color: 'yellow',\n}\n```\n\n> 数据字段\n\n- createdAt - 弹幕的创建时间 (**必须**)\n- time - 弹幕的动画时间 (**必须**)\n- text - 弹幕文本内容 (**必须**)\n- key - 数据的唯一标示 (**推荐**)\n- fontFamily - 弹幕文本的字体 (可选)\n- fontSize - 弹幕文本字号大小，单位：像素 (可选)\n- color - 弹幕文本的颜色 (可选)\n\n**关于 key**\n\n当动画过程中需要更新数据集时，推荐设置此字段。\n\n动态更新数据集时，为了动画的连续性，更新前后的数据集可能存在部分相同的数据。Barrage 组件内部会对更新前后的数据的 key 进行比较，只增量渲染那些新增的数据，而不改变已经存在的弹幕布局。\n\n综上所述，字段 key 的取值应该是稳定且唯一的。对于同一条弹幕而言，key 的值应该是不变的。\n\n### 装填弹幕\n\n装填弹幕有两种方式：\n\n**方式一：初始化时传入数据**\n\n```js\nconst barrage = new Barrage({\n  container: 'barrage',\n  data: JSON_DATA, // JSON_DATA -> 你的弹幕数据\n});\n```\n\n**方式二：初始化后更新数据**\n\n```js\nconst barrage = new Barrage({\n  container: 'barrage',\n});\n\nbarrage.setData(JSON_DATA); // JSON_DATA -> 你的弹幕数据\n```\n\n### 新增弹幕\n\n如果你的弹幕实例已创建或者正在播放，可以通过 `.add()` 方法新增一条记录：\n\n```js\nbarrage.add({\n  key: 'fctc651a9pm2j20bia8j',\n  time: 1000,\n  text: '这是新增的一条弹幕',\n  fontSize: 26,\n  color: '#0ff',\n});\n```\n\n`.add()` 方法一般搭配 数据提交/请求 操作进行使用，以实现真实的线上应用。\n\n> **适用场景：** 实现多终端同步的实时弹幕\n\n1. 某用户在客户端提交了一条弹幕到服务端\n2. 服务端将数据存储并分发给正在进行会话的客户端\n3. 客户端收到数据后，使用 `.add()` 方法进行数据更新\n\n## 动画控制接口\n\n### barrage.play()\n\n> **描述**\n\n用于播放动画。若当前为暂停状态，则从当前进度继续播放\n\n> **用例**\n\n```js\nbarrage.play();\n```\n\n### barrage.pause()\n\n> **描述**\n\n用于暂停动画\n\n> **用例**\n\n```js\nbarrage.pause();\n```\n\n### barrage.replay()\n\n> **描述**\n\n用于重新开始播放动画\n\n> **用例**\n\n```js\nbarrage.replay();\n```\n\n### barrage.goto(progress)\n\n> **描述**\n\n用于跳转播放进度。此方法在动画播放和暂停的状态下均有效\n\n> **参数**\n\nprogress - 待跳转的进度。值为一个毫秒数，表示跳转到动画的第几毫秒\n\n> **用例**\n\n```js\nbarrage.goto(15000); // 跳转到第 15 秒\n```\n\n## 动画状态属性\n\n### barrage.progress\n\n> **含义**\n\n当前动画的播放进度\n\n> **类型**\n\n描述播放进度的一个毫秒数\n\n### barrage.animState\n\n> **含义**\n\n当前动画的播放状态\n\n> **类型**\n\n描述播放状态的一个字符串：\n\n- 'ready' - 已就绪。即：barrage 实例已创建，但从未播放\n- 'paused' - 已暂停\n- 'playing' - 播放中\n\n## 其他接口&属性\n\n### barrage.setMask(mask)\n\n> **描述**\n\n用于设置蒙版图像。蒙版图像的概念见下文 [**蒙版弹幕**](#蒙版弹幕)\n\n> **参数**\n\nmask - 蒙版图像的 url 或 [ImageData](https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData)\n\n> **用例**\n\n```js\nbarrage.setMask('mask.png'); // 通过图片 url 设置蒙版图像\n\nbarrage.setMask(imageData); // 直接设置 ImageData 类型的数据\n```\n\n### barrage.clearMask()\n\n> **描述**\n\n用于清空当前的蒙版图像。清空后若不再重新设置蒙版图像，则动画将不再具有蒙版效果\n\n> **用例**\n\n```js\nbarrage.clearMask();\n```\n\n### barrage.canvas\n\n> **含义**\n\n渲染弹幕的 canvas 画布\n\n### barrage.ctx\n\n> **含义**\n\n画布的上下文，相当于 `barrage.canvas.getContext('2d')`\n\n## 蒙版弹幕\n\nBarrage 组件提供了实现 蒙版弹幕 效果的可能。基于本组件实现的 demo 效果如下：\n\n![蒙版弹幕效果](https://github.com/parksben/barrage/raw/master/images/demo.png)\n\n### 什么是“蒙版弹幕”\n\n**蒙版弹幕** 是由知名弹幕视频网站 [bilibili](https://www.bilibili.com) 于 2018 年中推出的一种弹幕渲染效果，可以有效减少弹幕文字对视频主体信息的干扰。\n\n详细资料可参考 bilibili 的相关文章：\n\n[弹幕阳光计划第十弹 蒙版听说过吗，弹幕黑科技了解一下？](https://www.bilibili.com/read/cv534194/)\n\n[不挡脸，放肆看！B 站黑科技蒙版弹幕揭秘](https://www.infoq.cn/article/2018%2F08%2Fbili-bili-mask-barrage)\n\n### 实现原理\n\n如果你熟悉最著名的图像处理软件——Adobe Photoshop，那么你应该对 “蒙版” 的概念不陌生，“蒙版弹幕” 的实现原理与此类似，即：将图像的一部分 “隐藏”。\n\nBarrage 组件的初始化参数中的 `mask` 一项即用于处理蒙版效果。对于上文截图中的效果，其使用的蒙版图像效果如下：\n\n![蒙版图像](https://github.com/parksben/barrage/raw/master/images/mask.png)\n\n弹幕渲染时，会将蒙版图像中 “镂空” 的部分（图像 RGBA 通道中 Alpha 通道为 0 的像素）去除，从而达到 “蒙版弹幕” 的效果。\n\n### 简单蒙版弹幕的实现\n\n为 barrage 实例设置蒙版图像(mask)即可实现蒙版弹幕效果。\n\n- 可通过初始化参数 `mask` 传入蒙版图像:\n\n```js\nimport Barrage from 'barrage-ui';\nimport example from 'barrage-ui/example.json';\n\nconst barrage = new Barrage({\n  container: 'barrage',\n  data: example,\n  mask: 'mask.png', // 传入蒙版图像的 url\n});\n```\n\n- 也可以在弹幕初始化后，通过 `.setMask()` 方法进行实时更新：\n\n```js\nimport Barrage from 'barrage-ui';\nimport example from 'barrage-ui/example.json';\n\nconst barrage = new Barrage({\n  container: 'barrage',\n  data: example,\n});\n\n// 设置蒙版图像\nbarrage.setMask('mask.png'); // 传入蒙版图像的 url\n```\n\n> **注意**\n>\n> `mask` 参数和 `.setMask()` 方法的参数类型一致，可接收图像的 url 或 [ImageData](https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData)\n\n### 实时渲染\n\n上文的示例仅能够实现一帧蒙版图像的渲染(只设置了一次 mask 而没有实时更新它)，要实现实时的蒙版效果(如：与视频实时同步的蒙版效果)，需要对弹幕动画的每一帧进行处理。\n\n使用组件提供的 beforeRender 钩子函数，可以轻易的实现：\n\n```js\nimport Barrage from 'barrage-ui';\nimport example from 'barrage-ui/example.json';\n\nconst barrage = new Barrage({\n  container: 'barrage',\n  data: example,\n  beforeRender: (ctx, progress) => {\n    const imageData = getMask(progress); // 用于获取当前进度对应蒙版的方法\n    barrage.setMask(imageData);\n  },\n});\n```\n\n当然，beforeRender 钩子也可以在弹幕初始化之后挂载：\n\n```js\nimport Barrage from 'barrage-ui';\nimport example from 'barrage-ui/example.json';\n\nconst barrage = new Barrage({\n  container: 'barrage',\n  data: example,\n});\n\nbarrage.beforeRender = (ctx, progress) => {\n  const imageData = getMask(progress); // 用于获取当前进度对应蒙版的方法\n  barrage.setMask(imageData);\n};\n```"}]